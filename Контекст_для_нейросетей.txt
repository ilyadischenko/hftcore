```
# HFT Trading Core - –ü–æ–ª–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç –ø—Ä–æ–µ–∫—Ç–∞

–Ø —Ä–∞–∑—Ä–∞–±–∞—Ç—ã–≤–∞—é –≤—ã—Å–æ–∫–æ—á–∞—Å—Ç–æ—Ç–Ω–æ–µ —Ç–æ—Ä–≥–æ–≤–æ–µ —è–¥—Ä–æ –Ω–∞ Rust —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π (hot-reload —á–µ—Ä–µ–∑ cdylib).

## 1. –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –°–ò–°–¢–ï–ú–´

### 1.1 –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã:

- **ExchangeData** (exchange_data.rs)
  - WebSocket: wss://fstream.binance.com/ws
  - –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ BookTicker –∏ Trades
  - –ü–∞—Ä—Å–∏–Ω–≥ —á–µ—Ä–µ–∑ simd_json (unsafe, –º—É—Ç–∞–±–µ–ª—å–Ω—ã–π –±—É—Ñ–µ—Ä)
  - –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è JSON ‚Üí C-—Ç–∏–ø—ã (CEvent)
  - Broadcast channel: 10000 —ç–ª–µ–º–µ–Ω—Ç–æ–≤
  - Auto-reconnect —á–µ—Ä–µ–∑ 3 —Å–µ–∫ –ø—Ä–∏ –æ–±—Ä—ã–≤–µ

- **ExchangeTrade** (exchange_trade.rs)
  - WebSocket: wss://ws-fapi.binance.com/ws-fapi/v1
  - HMAC-SHA256 –ø–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤
  - Time sync —Å Binance —á–µ—Ä–µ–∑ GET /fapi/v1/time
  - Backlog –º–µ—Ö–∞–Ω–∏–∑–º –¥–ª—è –Ω–µ–æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤
  - DashMap –¥–ª—è pending callbacks
  - Ping –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫, timeout 30 —Å–µ–∫

- **StrategyStorage** (strategies/storage.rs)
  - CRUD –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º–∏
  - –ö–æ–º–ø–∏–ª—è—Ü–∏—è —á–µ—Ä–µ–∑ cargo build --release
  - –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —à–∞–±–ª–æ–Ω–æ–≤ –∏–∑ copy_into_strategies/
  - –•—Ä–∞–Ω–µ–Ω–∏–µ –≤ strategies/db/{strategy_id}/

- **StrategyRunner** (strategies/manager.rs)
  - –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ .so/.dll/.dylib —á–µ—Ä–µ–∑ libloading
  - Bridge: async (broadcast) ‚Üí sync (crossbeam bounded)
  - spawn_blocking –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
  - Graceful shutdown —Å timeout 5 —Å–µ–∫

### 1.2 –ü–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö:

```
Binance WebSocket (market data)
       ‚Üì
simd_json –ø–∞—Ä—Å–∏–Ω–≥
       ‚Üì
CEvent {event_type, data, received_at_ns}
       ‚Üì
broadcast::channel<CEvent>(10000)
       ‚Üì
event_rx.recv() [async tokio]
       ‚Üì
Bridge task: try_send ‚Üí crossbeam::bounded(8192)
       ‚Üì
Receiver<CEvent> [sync, –≤ spawn_blocking]
       ‚Üì
–°—Ç—Ä–∞—Ç–µ–≥–∏—è (cdylib) –ø–æ–ª—É—á–∞–µ—Ç *mut Receiver<CEvent>
       ‚Üì
–û–±—Ä–∞–±–æ—Ç–∫–∞ ‚Üí place_order() FFI
       ‚Üì
tokio::runtime::Handle::spawn()
       ‚Üì
ExchangeTrade.send_limit_order()
       ‚Üì
Binance WebSocket (trading)
```

## 2. C FFI –¢–ò–ü–´

### 2.1 –°–æ–±—ã—Ç–∏—è (copy_into_strategies/types.rs):

```rust
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CEvent {
    pub event_type: u8,        // 0 = BookTicker, 1 = Trade
    pub data: CEventData,
    pub received_at_ns: u64,   // SystemTime::UNIX_EPOCH.as_nanos()
}

#[repr(C)]
#[derive(Clone, Copy)]
pub union CEventData {
    pub book_ticker: CBookTicker,
    pub trade: CTrade,
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct CBookTicker {
    pub symbol: [u8; 16],      // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤
    pub symbol_len: u8,        // —Ä–µ–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–∏–º–≤–æ–ª–∞
    pub bid_price: f64,
    pub ask_price: f64,
    pub bid_qty: f64,
    pub ask_qty: f64,
    pub time: i64,             // exchange timestamp
}

impl CBookTicker {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }
}

#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct CTrade {
    pub symbol: [u8; 16],
    pub symbol_len: u8,
    pub price: f64,
    pub qty: f64,              // –û–¢–†–ò–¶–ê–¢–ï–õ–¨–ù–´–ô –µ—Å–ª–∏ is_maker=true
    pub time: i64,
}

impl CTrade {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }
}
```

### 2.2 –¢–æ—Ä–≥–æ–≤—ã–µ —Ç–∏–ø—ã:

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct OrderResult {
    pub success: bool,
    pub order_id: i64,         // -1 –µ—Å–ª–∏ –æ—à–∏–±–∫–∞
    pub error_code: i32,       // Binance error code –∏–ª–∏ 0
}

pub type OrderCallback = unsafe extern "C" fn(result: OrderResult);

pub type PlaceOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    price: f64,
    quantity: f64,
    side: *const c_char,        // "BUY" –∏–ª–∏ "SELL"
    callback: OrderCallback,
);

pub type CancelOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    order_id: i64,
    callback: OrderCallback,
);
```

## 3. –°–¢–†–£–ö–¢–£–†–ê –§–ê–ô–õ–û–í

### 3.1 –ü—Ä–æ–µ–∫—Ç:

```
project_root/
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ main.rs                     # Axum —Å–µ—Ä–≤–µ—Ä, AppContext
‚îÇ   ‚îú‚îÄ‚îÄ exchange_data.rs            # Market data WS
‚îÇ   ‚îú‚îÄ‚îÄ exchange_trade.rs           # Trading WS
‚îÇ   ‚îú‚îÄ‚îÄ ffi_types.rs                # CEvent –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫—Ä–µ–π—Ç–∞
‚îÇ   ‚îî‚îÄ‚îÄ strategies/
‚îÇ       ‚îú‚îÄ‚îÄ mod.rs
‚îÇ       ‚îú‚îÄ‚îÄ storage.rs              # CRUD, –∫–æ–º–ø–∏–ª—è—Ü–∏—è
‚îÇ       ‚îú‚îÄ‚îÄ manager.rs              # StrategyRunner (libloading)
‚îÇ       ‚îî‚îÄ‚îÄ order.rs                # FFI —Ñ—É–Ω–∫—Ü–∏–∏ place_order/cancel_order
‚îÇ
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ strategy.rs                 # API endpoints
‚îÇ
‚îú‚îÄ‚îÄ copy_into_strategies/           # –®–ê–ë–õ–û–ù–´
‚îÇ   ‚îú‚îÄ‚îÄ types.rs                    # C FFI —Ç–∏–ø—ã (–∫–æ–ø–∏—Ä—É—é—Ç—Å—è –≤ –∫–∞–∂–¥—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é)
‚îÇ   ‚îî‚îÄ‚îÄ Cargo.toml                  # —Å {{STRATEGY_NAME}} placeholder
‚îÇ
‚îî‚îÄ‚îÄ strategies/db/                  # –•–†–ê–ù–ò–õ–ò–©–ï –°–¢–†–ê–¢–ï–ì–ò–ô
    ‚îî‚îÄ‚îÄ {strategy_id}/
        ‚îú‚îÄ‚îÄ Cargo.toml              # name = "strategy_id", crate-type = ["cdylib"]
        ‚îú‚îÄ‚îÄ metadata.json           # {id, name, symbol, enabled, created_at, updated_at}
        ‚îú‚îÄ‚îÄ src/
        ‚îÇ   ‚îú‚îÄ‚îÄ types.rs            # –ö–û–ü–ò–Ø –∏–∑ copy_into_strategies/types.rs
        ‚îÇ   ‚îî‚îÄ‚îÄ lib.rs              # mod types; use types::*; + –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–¥
        ‚îî‚îÄ‚îÄ target/release/
            ‚îî‚îÄ‚îÄ libstrategy_id.so   # —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞
```

### 3.2 metadata.json —Ñ–æ—Ä–º–∞—Ç:

```json
{
  "id": "sol_buyer",
  "name": "SOL Buyer Strategy",
  "symbol": "SOLUSDT",
  "enabled": false,
  "open_positions": true,
  "created_at": 1700000000,
  "updated_at": 1700000000
}
```

## 4. –°–¢–†–ê–¢–ï–ì–ò–ò

### 4.1 –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è:

```rust
use crossbeam::channel::Receiver;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;
use std::ffi::CString;

static STOP_FLAG: AtomicBool = AtomicBool::new(false);

unsafe extern "C" fn order_callback(result: OrderResult) {
    if result.success {
        println!("‚úÖ Order ID: {}", result.order_id);
    } else {
        println!("‚ùå Error code: {}", result.error_code);
    }
}

#[no_mangle]
pub extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,
    place_order: PlaceOrderFn,
    cancel_order: CancelOrderFn,
) -> i32 {
    let rx = unsafe { &*rx_ptr };
    
    let api_key = CString::new("YOUR_API_KEY").unwrap();
    let secret_key = CString::new("YOUR_SECRET").unwrap();
    let symbol = CString::new("SOLUSDT").unwrap();
    let side = CString::new("BUY").unwrap();
    
    while !STOP_FLAG.load(Ordering::Relaxed) {
        match rx.recv_timeout(Duration::from_millis(100)) {
            Ok(event) => {
                match event.event_type {
                    0 => {
                        let bt = unsafe { &event.data.book_ticker };
                        // –õ–æ–≥–∏–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                    }
                    1 => {
                        let trade = unsafe { &event.data.trade };
                        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç—Ä–µ–π–¥–æ–≤
                    }
                    _ => {}
                }
            }
            Err(crossbeam::channel::RecvTimeoutError::Timeout) => continue,
            Err(_) => break,
        }
    }
    0
}

#[no_mangle]
pub extern "C" fn stop() {
    STOP_FLAG.store(true, Ordering::Relaxed);
}
```

### 4.2 –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞ –∏–∑ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:

```rust
unsafe {
    place_order(
        api_key.as_ptr(),
        secret_key.as_ptr(),
        symbol.as_ptr(),
        127.50,              // price
        1.0,                 // quantity
        side.as_ptr(),
        order_callback,      // –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
    );
}
```

## 5. STORAGE (strategies/storage.rs)

### 5.1 –ö–ª—é—á–µ–≤—ã–µ –º–µ—Ç–æ–¥—ã:

```rust
impl StrategyStorage {
    pub fn new(base_path: &str) -> Result<Self> {
        // base_path –æ–±—ã—á–Ω–æ "strategies/db"
        // –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ copy_into_strategies/
        // –ó–∞–≥—Ä—É–∂–∞–µ—Ç —à–∞–±–ª–æ–Ω—ã types.rs –∏ Cargo.toml
    }
    
    pub fn create(&self, strategy: Strategy) -> Result<()> {
        // 1. –°–æ–∑–¥–∞—ë—Ç –ø–∞–ø–∫—É strategies/db/{id}/src/
        // 2. –ö–æ–ø–∏—Ä—É–µ—Ç Cargo.toml (–∑–∞–º–µ–Ω—è–µ—Ç {{STRATEGY_NAME}} –Ω–∞ id)
        // 3. –ö–æ–ø–∏—Ä—É–µ—Ç types.rs –≤ src/
        // 4. –°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–æ–¥ –≤ src/lib.rs (–¥–æ–±–∞–≤–ª—è–µ—Ç "mod types; use types::*;\n\n")
        // 5. –°–æ—Ö—Ä–∞–Ω—è–µ—Ç metadata.json
    }
    
    pub fn load(&self, id: &str) -> Result<Strategy> {
        // –ó–∞–≥—Ä—É–∂–∞–µ—Ç metadata.json –∏ src/lib.rs
        // load_code() —É–±–∏—Ä–∞–µ—Ç "mod types; use types::*;\n\n" –ø—Ä–µ—Ñ–∏–∫—Å
    }
    
    pub fn update_code(&self, id: &str, new_code: String) -> Result<()> {
        // –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ types.rs, –µ—Å–ª–∏ –Ω–µ—Ç - –∫–æ–ø–∏—Ä—É–µ—Ç
        // save_code() –¥–æ–±–∞–≤–ª—è–µ—Ç –∏–º–ø–æ—Ä—Ç –æ–±—Ä–∞—Ç–Ω–æ
        // –û–±–Ω–æ–≤–ª—è–µ—Ç updated_at
    }
    
    pub fn compile(&self, id: &str) -> Result<CompilationResult> {
        // –ó–∞–ø—É—Å–∫–∞–µ—Ç: cargo build --release --manifest-path {path}/Cargo.toml
        // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Ç—å –∫ lib{id}.so –∏–ª–∏ –æ—à–∏–±–∫–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
    }
    
    pub fn check(&self, id: &str) -> Result<CompilationResult> {
        // cargo check (–±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –±–µ–∑ –ª–∏–Ω–∫–æ–≤–∫–∏)
    }
}
```

### 5.2 copy_into_strategies/Cargo.toml:

```toml
[package]
name = "{{STRATEGY_NAME}}"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
crossbeam = "0.8"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
```

## 6. STRATEGY RUNNER (strategies/manager.rs)

### 6.1 –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∑–∞–ø—É—Å–∫–∞:

```rust
pub async fn start(
    &self,
    strategy_id: String,
    lib_path: PathBuf,
    mut event_rx: broadcast::Receiver<CEvent>,
) -> Result<()> {
    // 1. –ó–∞–≥—Ä—É–∂–∞–µ–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É
    let lib: Arc<Library> = Arc::new(unsafe { Library::new(&lib_path)? });
    
    // 2. –°–æ–∑–¥–∞—ë–º crossbeam bounded channel –¥–ª—è sync
    let (sync_tx, sync_rx) = bounded::<CEvent>(8192);
    
    // 3. Bridge task: async ‚Üí sync
    let bridge_task = tokio::spawn(async move {
        while let Ok(event) = event_rx.recv().await {
            match sync_tx.try_send(event) {
                Ok(_) => {},
                Err(crossbeam::channel::TrySendError::Full(_)) => {
                    // –°—Ç—Ä–∞—Ç–µ–≥–∏—è –æ—Ç—Å—Ç–∞—ë—Ç, –¥—Ä–æ–ø–∞–µ–º —Å–æ–±—ã—Ç–∏–µ
                }
                Err(_) => break,
            }
        }
    });
    
    // 4. –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏
    let run_fn: RunFn = unsafe { *lib.get(b"run")? };
    let stop_fn: StopFn = unsafe { *lib.get(b"stop")? };
    
    // 5. –ó–∞–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –≤ blocking thread
    let task = tokio::task::spawn_blocking(move || {
        let rx_ptr = Box::into_raw(Box::new(sync_rx));
        
        let result = unsafe { 
            run_fn(
                rx_ptr,
                crate::strategies::order::place_order,
                crate::strategies::order::cancel_order,
            )
        };
        
        unsafe { let _ = Box::from_raw(rx_ptr); }
        drop(lib_clone);
    });
    
    // 6. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ DashMap
    self.running.insert(strategy_id, RunningStrategy {
        _lib: lib,
        stop_fn,
        task,
        bridge_task,
    });
}
```

### 6.2 –û—Å—Ç–∞–Ω–æ–≤–∫–∞:

```rust
pub async fn stop(&self, strategy_id: &str) -> Result<()> {
    let (_, running) = self.running.remove(strategy_id)?;
    
    // 1. –í—ã–∑—ã–≤–∞–µ–º stop() –∏–∑ DLL
    unsafe { (running.stop_fn)(); }
    
    // 2. –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º bridge
    running.bridge_task.abort();
    
    // 3. –ñ–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å timeout
    tokio::time::timeout(Duration::from_secs(5), running.task).await?;
}
```

## 7. FFI –û–†–î–ï–†–ê (strategies/order.rs)

### 7.1 –ì–ª–æ–±–∞–ª—å–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä:

```rust
static TRADE_MANAGER: OnceLock<Arc<ExchangeTrade>> = OnceLock::new();

pub fn init_trading(manager: Arc<ExchangeTrade>) {
    TRADE_MANAGER.set(manager).ok();
}
```

### 7.2 place_order —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è:

```rust
#[no_mangle]
pub unsafe extern "C" fn place_order(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    price: f64,
    quantity: f64,
    side: *const c_char,
    callback: OrderCallback,
) {
    let manager = TRADE_MANAGER.get().expect("init_trading not called");
    
    // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º C-—Å—Ç—Ä–æ–∫–∏ ‚Üí Rust String
    let api_key_str = CStr::from_ptr(api_key).to_str().unwrap().to_string();
    let secret_key_str = CStr::from_ptr(secret_key).to_str().unwrap().to_string();
    let symbol_str = CStr::from_ptr(symbol).to_str().unwrap().to_string();
    let side_str = CStr::from_ptr(side).to_str().unwrap().to_string();
    
    // –ü–æ–ª—É—á–∞–µ–º tokio runtime handle (–≤–∞–∂–Ω–æ!)
    let handle = tokio::runtime::Handle::try_current().unwrap();
    
    let manager = manager.clone();
    
    handle.spawn(async move {
        manager.send_limit_order(
            &api_key_str,
            &secret_key_str,
            &symbol_str,
            price,
            quantity,
            &side_str,
            move |resp: serde_json::Value| {
                let result = if let Some(error) = resp.get("error") {
                    OrderResult {
                        success: false,
                        order_id: -1,
                        error_code: error["code"].as_i64().unwrap_or(-1) as i32,
                    }
                } else if let Some(order_id) = resp["result"]["orderId"].as_i64() {
                    OrderResult {
                        success: true,
                        order_id,
                        error_code: 0,
                    }
                } else {
                    OrderResult {
                        success: false,
                        order_id: -1,
                        error_code: -9998,
                    }
                };
                
                unsafe { callback(result); }
            },
        ).await;
    });
}
```

## 8. EXCHANGE TRADE (exchange_trade.rs)

### 8.1 –°—Ç—Ä—É–∫—Ç—É—Ä–∞:

```rust
pub struct ExchangeTrade {
    ws_url: String,
    is_connected: AtomicBool,
    out_tx: mpsc::Sender<Outbound>,
    ctrl_tx: mpsc::Sender<Ctrl>,
    event_tx: broadcast::Sender<Event>,
    pending: DashMap<String, Callback>,        // request_id ‚Üí callback
    inflight_ids: DashSet<String>,             // –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –Ω–æ –Ω–µ ACK
    id_counter: AtomicU64,
    time_offset_ms: AtomicI64,                 // sync —Å Binance
}
```

### 8.2 –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏:

```rust
pub async fn sync_time(&self) -> Result<i64> {
    let t0 = Utc::now().timestamp_millis();
    
    let client = reqwest::Client::new();
    let resp = client
        .get("https://fapi.binance.com/fapi/v1/time")
        .timeout(Duration::from_secs(5))
        .send()
        .await?;
    
    let t1 = Utc::now().timestamp_millis();
    
    let json: Value = resp.json().await?;
    let server_time = json["serverTime"].as_i64().unwrap();
    
    let network_delay = t1 - t0;
    let local_adjusted = t0 + network_delay / 2;
    let offset = server_time - local_adjusted;
    
    self.time_offset_ms.store(offset, Ordering::Relaxed);
    
    Ok(offset)
}
```

### 8.3 –ü–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞ (HMAC-SHA256):

```rust
fn build_message_for_cmd(&self, cmd: &Command, id: &str) -> Option<String> {
    let local_time = Utc::now().timestamp_millis();
    let offset = self.time_offset_ms.load(Ordering::Relaxed);
    let timestamp = local_time + offset;
    
    // BTreeMap –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞
    let mut params = BTreeMap::new();
    params.insert("apiKey", api_key.clone());
    params.insert("symbol", "SOLUSDT".to_string());
    params.insert("price", format!("{:.2}", price));
    params.insert("quantity", format!("{:.1}", quantity));
    params.insert("side", "BUY".to_string());
    params.insert("type", "LIMIT".to_string());
    params.insert("timeInForce", "GTC".to_string());
    params.insert("positionSide", "BOTH".to_string());
    params.insert("timestamp", timestamp.to_string());
    params.insert("recvWindow", "5000".to_string());
    
    // query string –¥–ª—è –ø–æ–¥–ø–∏—Å–∏
    let query = params.iter()
        .map(|(k, v)| format!("{k}={v}"))
        .collect::<Vec<_>>()
        .join("&");
    
    // HMAC-SHA256
    let mut mac = HmacSha256::new_from_slice(secret_key.as_bytes())?;
    mac.update(query.as_bytes());
    let signature = hex::encode(mac.finalize().into_bytes());
    
    // JSON —Å signature
    params.insert("signature", signature);
    
    let msg = json!({
        "id": id,
        "method": "order.place",
        "params": params
    });
    
    Some(msg.to_string())
}
```

### 8.4 WebSocket loop:

```rust
async fn run_socket(&self, ws_url: String, mut out_rx: mpsc::Receiver<Outbound>, mut ctrl_rx: mpsc::Receiver<Ctrl>) {
    let mut backlog: VecDeque<Outbound> = VecDeque::new();
    
    loop {
        match connect_async(&ws_url).await {
            Ok((ws, _)) => {
                self.is_connected.store(true, Ordering::Relaxed);
                let (mut write, mut read) = ws.split();
                
                // Reader task
                tokio::spawn(async move {
                    while let Ok(Some(Ok(Message::Text(txt)))) = 
                        timeout(Duration::from_secs(30), read.next()).await 
                    {
                        self.handle_text(txt).await;
                    }
                });
                
                // Writer loop
                let mut ping_tick = interval(Duration::from_secs(15));
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º backlog
                while let Some(msg) = backlog.pop_front() {
                    write.send(Message::Text(msg.payload)).await?;
                    self.inflight_ids.insert(msg.id);
                }
                
                // Main loop
                loop {
                    select! {
                        _ = ping_tick.tick() => {
                            write.send(Message::Ping(Vec::new())).await?;
                        }
                        msg = out_rx.recv() => {
                            if let Some(msg) = msg {
                                write.send(Message::Text(msg.payload)).await?;
                                self.inflight_ids.insert(msg.id);
                            }
                        }
                        ctrl = ctrl_rx.recv() => {
                            if let Some(Ctrl::Pong(data)) = ctrl {
                                write.send(Message::Pong(data)).await?;
                            }
                        }
                    }
                }
            }
            Err(e) => {
                self.is_connected.store(false, Ordering::Relaxed);
                sleep(Duration::from_secs(2)).await;
            }
        }
    }
}
```

## 9. EXCHANGE DATA (exchange_data.rs)

### 9.1 –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è JSON ‚Üí CEvent:

```rust
async fn handle_text(&self, mut txt: String) {
    let received_at_ns = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .unwrap()
        .as_nanos() as u64;
    
    if txt.contains("\"bookTicker\"") {
        match unsafe { simd_json::from_str::<RawBookTicker>(txt.as_mut_str()) } {
            Ok(bt) => {
                // –ö–æ–ø–∏—Ä—É–µ–º symbol –≤ [u8; 16]
                let mut symbol = [0u8; 16];
                let bytes = bt.symbol.as_bytes();
                let len = bytes.len().min(15);
                symbol[..len].copy_from_slice(&bytes[..len]);
                
                let c_event = CEvent {
                    event_type: 0,
                    data: CEventData {
                        book_ticker: CBookTicker {
                            symbol,
                            symbol_len: len as u8,
                            bid_price: bt.bid_price.parse().unwrap_or(0.0),
                            ask_price: bt.ask_price.parse().unwrap_or(0.0),
                            bid_qty: bt.bid_qty.parse().unwrap_or(0.0),
                            ask_qty: bt.ask_qty.parse().unwrap_or(0.0),
                            time: bt.time,
                        }
                    },
                    received_at_ns,
                };
                
                let _ = self.event_tx.send(c_event);
            }
            Err(e) => tracing::error!("Parse error: {}", e),
        }
    }
    
    // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ –¥–ª—è Trade
}
```

## 10. API ENDPOINTS

### 10.1 Market Data:
- POST /subscribe/bookticker - {"ticker": "solusdt"}
- POST /unsubscribe/bookticker
- POST /subscribe/trades
- POST /unsubscribe/trades

### 10.2 Trading:
- POST /order/test - {api_key, secret_key, symbol, price, quantity, side}
- POST /order/cancel - {api_key, secret_key, symbol, order_id}

### 10.3 Strategies CRUD:
- POST /strategies - {id, name, symbol, code}
- GET /strategies - —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö
- GET /strategies/:id - –ø–æ–ª—É—á–∏—Ç—å –æ–¥–Ω—É
- DELETE /strategies/:id
- PUT /strategies/:id/code - {code}
- PUT /strategies/:id/metadata - {name?, symbol?, enabled?, open_positions?}
- POST /strategies/:id/compile
- POST /strategies/:id/check

### 10.4 Strategies Runtime:
- POST /strategies/:id/start
- POST /strategies/:id/stop
- GET /strategies/running

## 11. MAIN.RS

### 11.1 AppContext:

```rust
#[derive(Clone)]
struct AppContext {
    data_manager: Arc<ExchangeData>,
    trade_manager: Arc<ExchangeTrade>,
    event_broadcaster: broadcast::Sender<CEvent>,
}
```

### 11.2 –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è:

```rust
#[tokio::main]
async fn main() {
    tracing_subscriber::fmt().compact().init();
    
    let (event_tx, _) = broadcast::channel::<CEvent>(10000);
    
    let data_manager = ExchangeData::new(
        "wss://fstream.binance.com/ws".to_string(),
        event_tx.clone()
    );
    
    let trade_manager = ExchangeTrade::new(
        "wss://ws-fapi.binance.com/ws-fapi/v1".to_string()
    );
    
    // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏
    match trade_manager.sync_time().await {
        Ok(offset) => {
            if offset.abs() > 1000 {
                tracing::warn!("Large offset: {}ms", offset);
            } else {
                tracing::info!("Time offset: {}ms", offset);
            }
        }
        Err(e) => {
            tracing::error!("Time sync failed: {}", e);
            trade_manager.set_time_offset(-1000);
        }
    }
    
    // –í–ê–ñ–ù–û: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π TRADE_MANAGER
    crate::strategies::order::init_trading(trade_manager.clone());
    
    let app_state = Arc::new(AppContext {
        data_manager,
        trade_manager,
        event_broadcaster: event_tx.clone(),
    });
    
    let strategy_storage = Arc::new(
        StrategyStorage::new("./strategies/db").unwrap()
    );
    
    let strategy_runner = StrategyRunner::new();
    
    let app = Router::new()
        .route("/subscribe/bookticker", post(subscribe_bookticker))
        .route("/order/test", post(test_order))
        .with_state(app_state.clone())
        .merge(strategy::strategy_routes(strategy_storage.clone()))
        .merge(strategy::runtime_routes(strategy_storage, strategy_runner, event_tx));
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await.unwrap();
    tracing::info!("üöÄ Server running on http://0.0.0.0:8080");
    axum::serve(listener, app).await.unwrap();
}
```

## 12. –ü–†–ò–ú–ï–†–´ –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø

### 12.1 –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ —á–µ—Ä–µ–∑ API:

```bash
curl -X POST http://localhost:8080/strategies \
  -H "Content-Type: application/json" \
  -d '{
    "id": "sol_buyer",
    "name": "SOL Buyer",
    "symbol": "SOLUSDT",
    "code": "use crossbeam::channel::Receiver;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::time::{Instant, Duration};\nuse std::ffi::CString;\n\nstatic STOP_FLAG: AtomicBool = AtomicBool::new(false);\n\nstruct Strategy {\n    orders_sent: u64,\n    last_order_time: Instant,\n}\n\nimpl Strategy {\n    fn new() -> Self {\n        Self {\n            orders_sent: 0,\n            last_order_time: Instant::now(),\n        }\n    }\n    \n    fn should_place_order(&self) -> bool {\n        self.last_order_time.elapsed() >= Duration::from_secs(20)\n    }\n}\n\nunsafe extern \"C\" fn order_callback(result: OrderResult) {\n    if result.success {\n        println!(\"‚úÖ Order ID: {}\", result.order_id);\n    } else {\n        println!(\"‚ùå Error: {}\", result.error_code);\n    }\n}\n\n#[no_mangle]\npub extern \"C\" fn run(\n    rx_ptr: *mut Receiver<CEvent>,\n    place_order: PlaceOrderFn,\n    _cancel_order: CancelOrderFn,\n) -> i32 {\n    let rx = unsafe { &*rx_ptr };\n    let mut strategy = Strategy::new();\n    \n    let api_key = CString::new(\"YOUR_KEY\").unwrap();\n    let secret_key = CString::new(\"YOUR_SECRET\").unwrap();\n    let symbol = CString::new(\"SOLUSDT\").unwrap();\n    let side = CString::new(\"BUY\").unwrap();\n    \n    while !STOP_FLAG.load(Ordering::Relaxed) {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(_) => {\n                if strategy.should_place_order() {\n                    unsafe {\n                        place_order(\n                            api_key.as_ptr(),\n                            secret_key.as_ptr(),\n                            symbol.as_ptr(),\n                            127.0,\n                            1.0,\n                            side.as_ptr(),\n                            order_callback,\n                        );\n                    }\n                    strategy.orders_sent += 1;\n                    strategy.last_order_time = Instant::now();\n                }\n            }\n            Err(crossbeam::channel::RecvTimeoutError::Timeout) => continue,\n            Err(_) => break,\n        }\n    }\n    0\n}\n\n#[no_mangle]\npub extern \"C\" fn stop() {\n    STOP_FLAG.store(true, Ordering::Relaxed);\n}"
  }'
```

### 12.2 Workflow –∑–∞–ø—É—Å–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:

```bash
# 1. –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –¥–∞–Ω–Ω—ã–µ
curl -X POST http://localhost:8080/subscribe/bookticker \
  -H "Content-Type: application/json" \
  -d '{"ticker":"solusdt"}'

# 2. –°–æ–∑–¥–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é (—Å–º. –≤—ã—à–µ)

# 3. –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
curl -X POST http://localhost:8080/strategies/sol_buyer/start

# 4. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
curl http://localhost:8080/strategies/running

# 5. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
curl -X POST http://localhost:8080/strategies/sol_buyer/stop
```

## 13. –í–ê–ñ–ù–´–ï –î–ï–¢–ê–õ–ò

### 13.1 Binance Futures –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (SOLUSDT):
- tickSize (—Ü–µ–Ω–∞): 0.01
- stepSize (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ): 1.0
- minQty: 1.0
- –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ: (value / tick_size).round() * tick_size

### 13.2 API –∫–ª—é—á–∏ (testnet):
```
API_KEY: ay0LdRfUbErVi6jTAanIjiuASqId3oLQYibIwCRQY3OLKiKdHCVGvLQgtH9X5wWm
SECRET: 3AJ2HfjBkNPKwfsPswkzAkqVx6Jawm3xSQTOMKJ1ib5e4Wa9DEM5ddvfhDjeqPO4
```

### 13.3 –ü–∞—Ç—Ç–µ—Ä–Ω—ã –≤ –∫–æ–¥–µ:

**Arc<Mutex<Option<oneshot::Sender>>>** - –¥–ª—è callback‚Üíasync:
```rust
let tx = Arc::new(Mutex::new(Some(tx)));
let tx_clone = tx.clone();
tokio::spawn(async move {
    if let Some(sender) = tx_clone.lock().await.take() {
        sender.send(data).ok();
    }
});
```

**DashMap vs HashMap** - thread-safe –±–µ–∑ Mutex
**AtomicBool –¥–ª—è STOP_FLAG** - –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏–∑ –¥—Ä—É–≥–æ–≥–æ –ø–æ—Ç–æ–∫–∞
**recv_timeout(100ms)** - –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–æ–≤–µ—Ä—è—Ç—å STOP_FLAG —Ä–µ–≥—É–ª—è—Ä–Ω–æ

### 13.4 –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:
- simd_json (unsafe) –≤–º–µ—Å—Ç–æ serde_json
- ryu::Buffer –¥–ª—è f64‚Üístring –±–µ–∑ –∞–ª–ª–æ–∫–∞—Ü–∏–π
- BTreeMap –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
- Stack allocation –¥–ª—è symbol [u8; 16] –≤–º–µ—Å—Ç–æ String
- SharedStr = Arc<String> –¥–ª—è –∏–∑–±–µ–∂–∞–Ω–∏—è –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è payload

---

–¢–µ–ø–µ—Ä—å —Ç—ã –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –ø—Ä–æ–µ–∫—Ç–∞. –ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å —Ä–∞–±–æ—Ç—É!
```