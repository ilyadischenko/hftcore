```
# –†–∞–∑—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –¥–ª—è HFT Trading Core

–Ø –ø–∏—à—É —Ç–æ—Ä–≥–æ–≤—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–∞ Rust, –∫–æ—Ç–æ—Ä—ã–µ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤ cdylib –∏ –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏ –≤ —Ç–æ—Ä–≥–æ–≤–æ–µ —è–¥—Ä–æ.

## 1. –°–¢–†–£–ö–¢–£–†–ê –°–¢–†–ê–¢–ï–ì–ò–ò

### 1.1 –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã:

```rust
use crossbeam::channel::Receiver;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;
use std::ffi::CString;

// –ì–ª–æ–±–∞–ª—å–Ω—ã–π —Ñ–ª–∞–≥ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
static STOP_FLAG: AtomicBool = AtomicBool::new(false);

// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞
#[no_mangle]
pub extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,    // –ö–∞–Ω–∞–ª —Å–æ–±—ã—Ç–∏–π
    place_order: PlaceOrderFn,        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ä–¥–µ—Ä–æ–≤
    cancel_order: CancelOrderFn,      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã –æ—Ä–¥–µ—Ä–æ–≤
) -> i32 {
    // –õ–æ–≥–∏–∫–∞ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
    0  // –ö–æ–¥ –≤–æ–∑–≤—Ä–∞—Ç–∞
}

// –û–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
#[no_mangle]
pub extern "C" fn stop() {
    STOP_FLAG.store(true, Ordering::Relaxed);
}
```

### 1.2 –ß—Ç–æ –ù–ï –ù–£–ñ–ù–û –ø–∏—Å–∞—Ç—å (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è):

- `mod types; use types::*;` - –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
- –í–µ—Å—å —Ñ–∞–π–ª `types.rs` - –∫–æ–ø–∏—Ä—É–µ—Ç—Å—è –∏–∑ —à–∞–±–ª–æ–Ω–∞
- `Cargo.toml` - –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏

## 2. –î–û–°–¢–£–ü–ù–´–ï –¢–ò–ü–´

### 2.1 –°–æ–±—ã—Ç–∏—è:

```rust
// –ü—Ä–∏—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ rx.recv()
struct CEvent {
    event_type: u8,         // 0 = BookTicker, 1 = Trade
    data: CEventData,       // union
    received_at_ns: u64,    // timestamp –ø–æ–ª—É—á–µ–Ω–∏—è
}

union CEventData {
    book_ticker: CBookTicker,
    trade: CTrade,
}
```

### 2.2 BookTicker (–ª—É—á—à–∏–µ bid/ask):

```rust
struct CBookTicker {
    symbol: [u8; 16],       // —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤
    symbol_len: u8,         // —Ä–µ–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞
    bid_price: f64,         // –ª—É—á—à–∞—è —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏
    ask_price: f64,         // –ª—É—á—à–∞—è —Ü–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏
    bid_qty: f64,           // –æ–±—ä—ë–º –Ω–∞ bid
    ask_qty: f64,           // –æ–±—ä—ë–º –Ω–∞ ask
    time: i64,              // exchange timestamp
}

// –•–µ–ª–ø–µ—Ä –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–∞ –∫–∞–∫ —Å—Ç—Ä–æ–∫–∏
impl CBookTicker {
    pub fn symbol_str(&self) -> &str;
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
let bt = unsafe { &event.data.book_ticker };
if bt.symbol_str() == "solusdt" {
    println!("Bid: {:.2}, Ask: {:.2}", bt.bid_price, bt.ask_price);
}
```

### 2.3 Trade (–∏—Å–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ —Å–¥–µ–ª–∫–∏):

```rust
struct CTrade {
    symbol: [u8; 16],
    symbol_len: u8,
    price: f64,             // —Ü–µ–Ω–∞ —Å–¥–µ–ª–∫–∏
    qty: f64,               // –û–¢–†–ò–¶–ê–¢–ï–õ–¨–ù–´–ô –µ—Å–ª–∏ maker sell
    time: i64,
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
let trade = unsafe { &event.data.trade };
let side = if trade.qty > 0.0 { "BUY" } else { "SELL" };
println!("{} {} @ {:.2}", side, trade.qty.abs(), trade.price);
```

### 2.4 –û—Ä–¥–µ—Ä–∞:

```rust
struct OrderResult {
    success: bool,          // true –µ—Å–ª–∏ –æ—Ä–¥–µ—Ä —Å–æ–∑–¥–∞–Ω
    order_id: i64,          // ID –æ—Ä–¥–µ—Ä–∞ –∏–ª–∏ -1
    error_code: i32,        // Binance error code –∏–ª–∏ 0
}

// Callback –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –æ—Ç –±–∏—Ä–∂–∏
type OrderCallback = unsafe extern "C" fn(result: OrderResult);

// –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ä–¥–µ—Ä–∞
type PlaceOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    price: f64,
    quantity: f64,
    side: *const c_char,    // "BUY" –∏–ª–∏ "SELL"
    callback: OrderCallback,
);
```

## 3. –û–°–ù–û–í–ù–´–ï –ü–ê–¢–¢–ï–†–ù–´

### 3.1 –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è (–∫–∞—Ä–∫–∞—Å):

```rust
use crossbeam::channel::Receiver;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;
use std::ffi::CString;

static STOP_FLAG: AtomicBool = AtomicBool::new(false);

struct Strategy {
    // –í–∞—à–∏ –ø–æ–ª—è
}

impl Strategy {
    fn new() -> Self {
        Self { /* ... */ }
    }
    
    fn on_book_ticker(&mut self, bt: &CBookTicker) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ BookTicker
    }
    
    fn on_trade(&mut self, trade: &CTrade) {
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ Trade
    }
}

#[no_mangle]
pub extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,
    place_order: PlaceOrderFn,
    cancel_order: CancelOrderFn,
) -> i32 {
    let rx = unsafe { &*rx_ptr };
    let mut strategy = Strategy::new();
    
    while !STOP_FLAG.load(Ordering::Relaxed) {
        match rx.recv_timeout(Duration::from_millis(100)) {
            Ok(event) => {
                match event.event_type {
                    0 => strategy.on_book_ticker(unsafe { &event.data.book_ticker }),
                    1 => strategy.on_trade(unsafe { &event.data.trade }),
                    _ => {}
                }
            }
            Err(crossbeam::channel::RecvTimeoutError::Timeout) => continue,
            Err(_) => break,
        }
    }
    0
}

#[no_mangle]
pub extern "C" fn stop() {
    STOP_FLAG.store(true, Ordering::Relaxed);
}
```

### 3.2 –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞:

```rust
// –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö (–¥–µ–ª–∞–µ–º –æ–¥–∏–Ω —Ä–∞–∑)
let api_key = CString::new("YOUR_API_KEY").unwrap();
let secret_key = CString::new("YOUR_SECRET").unwrap();
let symbol = CString::new("SOLUSDT").unwrap();
let side_buy = CString::new("BUY").unwrap();

// Callback –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
unsafe extern "C" fn order_callback(result: OrderResult) {
    if result.success {
        println!("‚úÖ Order placed! ID: {}", result.order_id);
    } else {
        println!("‚ùå Order failed! Error: {}", result.error_code);
    }
}

// –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞
unsafe {
    place_order(
        api_key.as_ptr(),
        secret_key.as_ptr(),
        symbol.as_ptr(),
        127.50,              // —Ü–µ–Ω–∞
        1.0,                 // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
        side_buy.as_ptr(),
        order_callback,      // –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
    );
}
```

### 3.3 –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Å–∏–º–≤–æ–ª—É:

```rust
fn on_book_ticker(&mut self, bt: &CBookTicker) {
    // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –±–µ–∑ —É—á—ë—Ç–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞
    if !bt.symbol_str().eq_ignore_ascii_case("solusdt") {
        return;  // –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –¥—Ä—É–≥–∏–µ —Å–∏–º–≤–æ–ª—ã
    }
    
    // –†–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å SOLUSDT
    println!("SOL bid: {:.2}", bt.bid_price);
}
```

### 3.4 –û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π:

```rust
struct Strategy {
    last_bid: f64,
    changes_count: u64,
}

impl Strategy {
    fn on_book_ticker(&mut self, bt: &CBookTicker) -> bool {
        if bt.symbol_str().eq_ignore_ascii_case("solusdt") {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            if bt.bid_price != self.last_bid && self.last_bid != 0.0 {
                self.changes_count += 1;
                self.last_bid = bt.bid_price;
                return true;  // –±—ã–ª–æ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
            }
            self.last_bid = bt.bid_price;
        }
        false
    }
}
```

### 3.5 –¢–∞–π–º–µ—Ä (–≤—ã–ø–æ–ª–Ω—è—Ç—å –∫–∞–∂–¥—ã–µ N —Å–µ–∫—É–Ω–¥):

```rust
use std::time::Instant;

struct Strategy {
    last_action_time: Instant,
}

impl Strategy {
    fn should_act(&self) -> bool {
        self.last_action_time.elapsed() >= Duration::from_secs(20)
    }
    
    fn reset_timer(&mut self) {
        self.last_action_time = Instant::now();
    }
}

// –í main loop:
if strategy.should_act() {
    // –í—ã–ø–æ–ª–Ω—è–µ–º –¥–µ–π—Å—Ç–≤–∏–µ
    unsafe { place_order(...); }
    strategy.reset_timer();
}
```

### 3.6 –°—á—ë—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏–π:

```rust
struct Strategy {
    events_count: u64,
}

fn on_book_ticker(&mut self, bt: &CBookTicker) {
    self.events_count += 1;
    
    // –ö–∞–∂–¥—ã–µ 100 —Å–æ–±—ã—Ç–∏–π
    if self.events_count % 100 == 0 {
        println!("Processed {} events", self.events_count);
    }
}
```

## 4. –ß–ê–°–¢–´–ï –ó–ê–î–ê–ß–ò

### 4.1 –û—Ä–¥–µ—Ä –∫–∞–∂–¥—ã–µ N —Å–µ–∫—É–Ω–¥:

```rust
struct Strategy {
    last_order_time: Instant,
    orders_sent: u64,
}

impl Strategy {
    fn new() -> Self {
        Self {
            last_order_time: Instant::now(),
            orders_sent: 0,
        }
    }
}

#[no_mangle]
pub extern "C" fn run(rx_ptr: *mut Receiver<CEvent>, place_order: PlaceOrderFn, ...) -> i32 {
    let rx = unsafe { &*rx_ptr };
    let mut strategy = Strategy::new();
    
    let api_key = CString::new("KEY").unwrap();
    let secret_key = CString::new("SECRET").unwrap();
    let symbol = CString::new("SOLUSDT").unwrap();
    let side = CString::new("BUY").unwrap();
    
    while !STOP_FLAG.load(Ordering::Relaxed) {
        match rx.recv_timeout(Duration::from_millis(100)) {
            Ok(_) => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∞–π–º–µ—Ä
                if strategy.last_order_time.elapsed() >= Duration::from_secs(20) {
                    unsafe {
                        place_order(
                            api_key.as_ptr(),
                            secret_key.as_ptr(),
                            symbol.as_ptr(),
                            127.0,
                            1.0,
                            side.as_ptr(),
                            |result| {
                                if result.success {
                                    println!("‚úÖ Order: {}", result.order_id);
                                }
                            },
                        );
                    }
                    strategy.orders_sent += 1;
                    strategy.last_order_time = Instant::now();
                }
            }
            Err(crossbeam::channel::RecvTimeoutError::Timeout) => continue,
            Err(_) => break,
        }
    }
    0
}
```

### 4.2 –û—Ä–¥–µ—Ä –Ω–∞ N –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ü–µ–Ω—ã:

```rust
struct Strategy {
    last_bid: f64,
    changes_count: u64,
}

fn on_book_ticker(&mut self, bt: &CBookTicker) -> bool {
    if bt.symbol_str().eq_ignore_ascii_case("solusdt") {
        if bt.bid_price != self.last_bid && self.last_bid != 0.0 {
            self.changes_count += 1;
            
            if self.changes_count % 100 == 0 {
                self.last_bid = bt.bid_price;
                return true;  // —Å–∏–≥–Ω–∞–ª –Ω–∞ –æ—Ä–¥–µ—Ä
            }
        }
        self.last_bid = bt.bid_price;
    }
    false
}

// –í main loop:
if event.event_type == 0 {
    let bt = unsafe { &event.data.book_ticker };
    if strategy.on_book_ticker(bt) {
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä
    }
}
```

### 4.3 –û—Ä–¥–µ—Ä –Ω–∞ % –æ—Ç —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã:

```rust
fn get_order_price(current_bid: f64, offset_percent: f64) -> f64 {
    let price = current_bid * (1.0 + offset_percent / 100.0);
    // –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ –¥–æ tick_size (0.01 –¥–ª—è SOLUSDT)
    (price * 100.0).round() / 100.0
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
let order_price = get_order_price(bt.bid_price, -1.0);  // -1% –æ—Ç bid
```

### 4.4 –ü—Ä–æ—Å—Ç–æ–π —Å–ø—Ä–µ–¥:

```rust
fn get_mid_price(bt: &CBookTicker) -> f64 {
    (bt.bid_price + bt.ask_price) / 2.0
}

fn get_spread(bt: &CBookTicker) -> f64 {
    bt.ask_price - bt.bid_price
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
let mid = get_mid_price(bt);
let spread = get_spread(bt);
println!("Mid: {:.2}, Spread: {:.4}", mid, spread);
```

### 4.5 –°–∫–æ–ª—å–∑—è—â–µ–µ —Å—Ä–µ–¥–Ω–µ–µ:

```rust
use std::collections::VecDeque;

struct Strategy {
    prices: VecDeque<f64>,
    window: usize,
}

impl Strategy {
    fn new(window: usize) -> Self {
        Self {
            prices: VecDeque::with_capacity(window + 1),
            window,
        }
    }
    
    fn update(&mut self, price: f64) {
        self.prices.push_back(price);
        if self.prices.len() > self.window {
            self.prices.pop_front();
        }
    }
    
    fn average(&self) -> Option<f64> {
        if self.prices.len() < self.window {
            return None;
        }
        Some(self.prices.iter().sum::<f64>() / self.window as f64)
    }
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
strategy.update(bt.bid_price);
if let Some(avg) = strategy.average() {
    println!("MA: {:.2}", avg);
}
```

## 5. –í–ê–ñ–ù–´–ï –ü–†–ê–í–ò–õ–ê

### 5.1 Binance –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (SOLUSDT):
- **tickSize** (—Ü–µ–Ω–∞): 0.01 - —Ü–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫—Ä–∞—Ç–Ω–∞ 0.01
- **stepSize** (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ): 1.0 - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–∞—Ç–Ω–æ 1.0
- **minQty**: 1.0 - –º–∏–Ω–∏–º—É–º 1 SOL –Ω–∞ –æ—Ä–¥–µ—Ä

### 5.2 –û–∫—Ä—É–≥–ª–µ–Ω–∏–µ:

```rust
fn round_price(price: f64) -> f64 {
    (price / 0.01).round() * 0.01
}

fn round_quantity(qty: f64) -> f64 {
    (qty / 1.0).round() * 1.0
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
let price = round_price(127.456);  // 127.46
let qty = round_quantity(1.3);     // 1.0
```

### 5.3 recv_timeout:
- –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π `recv_timeout(Duration::from_millis(100))`
- –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø—Ä–æ–≤–µ—Ä—è—Ç—å STOP_FLAG —Ä–µ–≥—É–ª—è—Ä–Ω–æ
- Timeout –ù–ï –æ–∑–Ω–∞—á–∞–µ—Ç –æ—à–∏–±–∫—É - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ

### 5.4 CString —Å–æ–∑–¥–∞–≤–∞—Ç—å –æ–¥–∏–Ω —Ä–∞–∑:
```rust
// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: —Å–æ–∑–¥–∞—ë–º –æ–¥–∏–Ω —Ä–∞–∑ –ø–µ—Ä–µ–¥ —Ü–∏–∫–ª–æ–º
let api_key = CString::new("KEY").unwrap();
while !STOP_FLAG.load(Ordering::Relaxed) {
    unsafe { place_order(api_key.as_ptr(), ...); }
}

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: —Å–æ–∑–¥–∞—ë–º –≤ —Ü–∏–∫–ª–µ (–º–µ–¥–ª–µ–Ω–Ω–æ)
while !STOP_FLAG.load(Ordering::Relaxed) {
    let api_key = CString::new("KEY").unwrap();  // –∫–∞–∂–¥—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é!
    unsafe { place_order(api_key.as_ptr(), ...); }
}
```

### 5.5 Callback –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å unsafe extern "C":
```rust
// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û
unsafe extern "C" fn my_callback(result: OrderResult) {
    println!("Order: {}", result.order_id);
}

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û
fn my_callback(result: OrderResult) {  // –Ω–µ extern "C"
    println!("Order: {}", result.order_id);
}
```

## 6. –®–ê–ë–õ–û–ù –î–õ–Ø –ë–´–°–¢–†–û–ì–û –°–¢–ê–†–¢–ê

```rust
use crossbeam::channel::Receiver;
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::{Duration, Instant};
use std::ffi::CString;

static STOP_FLAG: AtomicBool = AtomicBool::new(false);

struct Strategy {
    // TODO: –¥–æ–±–∞–≤—å —Å–≤–æ–∏ –ø–æ–ª—è
}

impl Strategy {
    fn new() -> Self {
        Self {
            // TODO: –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        }
    }
    
    fn on_book_ticker(&mut self, bt: &CBookTicker) {
        if !bt.symbol_str().eq_ignore_ascii_case("solusdt") {
            return;
        }
        
        // TODO: –ª–æ–≥–∏–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ BookTicker
    }
}

unsafe extern "C" fn order_callback(result: OrderResult) {
    if result.success {
        println!("‚úÖ Order ID: {}", result.order_id);
    } else {
        println!("‚ùå Error: {}", result.error_code);
    }
}

#[no_mangle]
pub extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,
    place_order: PlaceOrderFn,
    _cancel_order: CancelOrderFn,
) -> i32 {
    println!("üöÄ Strategy started");
    
    let rx = unsafe { &*rx_ptr };
    let mut strategy = Strategy::new();
    
    let api_key = CString::new("YOUR_API_KEY").unwrap();
    let secret_key = CString::new("YOUR_SECRET_KEY").unwrap();
    let symbol = CString::new("SOLUSDT").unwrap();
    let side = CString::new("BUY").unwrap();
    
    while !STOP_FLAG.load(Ordering::Relaxed) {
        match rx.recv_timeout(Duration::from_millis(100)) {
            Ok(event) if event.event_type == 0 => {
                let bt = unsafe { &event.data.book_ticker };
                strategy.on_book_ticker(bt);
                
                // TODO: —É—Å–ª–æ–≤–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ä–¥–µ—Ä–∞
                if false {  // –∑–∞–º–µ–Ω–∏ –Ω–∞ —Å–≤–æ–µ —É—Å–ª–æ–≤–∏–µ
                    unsafe {
                        place_order(
                            api_key.as_ptr(),
                            secret_key.as_ptr(),
                            symbol.as_ptr(),
                            127.0,  // TODO: –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è —Ü–µ–Ω–∞
                            1.0,
                            side.as_ptr(),
                            order_callback,
                        );
                    }
                }
            }
            Err(crossbeam::channel::RecvTimeoutError::Timeout) => continue,
            Err(_) => break,
            _ => {}
        }
    }
    
    println!("üõë Strategy stopped");
    0
}

#[no_mangle]
pub extern "C" fn stop() {
    println!("üõë Stop signal received");
    STOP_FLAG.store(true, Ordering::Relaxed);
}
```

---

–¢–µ–ø–µ—Ä—å —Ç—ã –∑–Ω–∞–µ—à—å –∫–∞–∫ –ø–∏—Å–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏. –ñ–¥—É –∑–∞–¥–∞—á—É!
```