–ù–∏–∂–µ –∑–∞–≥–æ—Ç–æ–≤–∫–∞‚Äë–æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ä–µ–¥—ã, –∫–æ—Ç–æ—Ä—É—é –º–æ–∂–Ω–æ –¥–∞–≤–∞—Ç—å –¥—Ä—É–≥–∏–º –Ω–µ–π—Ä–æ—Å–µ—Ç—è–º, —á—Ç–æ–±—ã –æ–Ω–∏ –ø–æ–Ω–∏–º–∞–ª–∏, –∫–∞–∫ –ø–∏—Å–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø–æ–¥ —Ç–≤–æ—ë —è–¥—Ä–æ. –û–Ω–∞ –∫–æ—Ä–æ—Ç–∫–∞—è, –Ω–æ —Å –Ω—É–∂–Ω—ã–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏ —Å–ø–∏—Å–∫–æ–º –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤.

---

## –ö–æ–Ω—Ç–µ–∫—Å—Ç: –∫–∞–∫ —É—Å—Ç—Ä–æ–µ–Ω—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

- –°—Ç—Ä–∞—Ç–µ–≥–∏—è ‚Äî —ç—Ç–æ –æ—Ç–¥–µ–ª—å–Ω–∞—è Rust‚Äë–±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (`cdylib`) —Å —Ñ–∞–π–ª–æ–º `src/lib.rs`.
- –í –Ω–∞—á–∞–ª–µ `lib.rs` **—É–∂–µ** –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è:

  ```rust
  mod types;
  use types::*;
  ```

  –ú–æ–¥—É–ª—å `types` —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω —è–¥—Ä–æ–º –∏ —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ FFI‚Äë—Ç–∏–ø—ã –∏ —Ñ—É–Ω–∫—Ü–∏–∏, –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏.

- –Ø–¥—Ä–æ –∑–∞–≥—Ä—É–∂–∞–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∫–∞–∫ `.so/.dll` –∏ –≤—ã–∑—ã–≤–∞–µ—Ç –¥–≤–∞ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –º–µ—Ç–æ–¥–∞:

  ```rust
  #[no_mangle]
  pub extern "C" fn run(
      rx: *mut crossbeam::channel::Receiver<CEvent>,
      place_order: PlaceOrderFn,
      cancel_order: CancelOrderFn,
      config: StrategyConfig,
  ) -> i32 { ... }

  #[no_mangle]
  pub extern "C" fn stop() { ... }
  ```

- `run` –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ (—á–µ—Ä–µ–∑ `spawn_blocking`) –∏ –¥–æ–ª–∂–µ–Ω —Å–∞–º –∫—Ä—É—Ç–∏—Ç—å —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å–æ–±—ã—Ç–∏–π –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Ñ–ª–∞–≥ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ (–æ–±—ã—á–Ω–æ —á–µ—Ä–µ–∑ `AtomicBool`, –∫–æ—Ç–æ—Ä—ã–π –º–µ–Ω—è–µ—Ç—Å—è –≤ `stop()`).

---

## –î–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–∏–ø—ã (–∏–∑ `mod types`)

### –†—ã–Ω–æ—á–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è

```rust
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CEvent {
    pub event_type: u8,      // 0 = book_ticker, 1 = trade
    pub data: CEventData,    // union –Ω–∏–∂–µ
    pub received_at_ns: u64, // –≤—Ä–µ–º—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤ —è–¥—Ä–µ, –Ω—Å
}

#[repr(C)]
#[derive(Clone, Copy)]
pub union CEventData {
    pub book_ticker: CBookTicker,
    pub trade: CTrade,
}
```

#### BookTicker (–ª—É—á—à–∏–π –±–∏–¥/–∞—Å–∫)

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct CBookTicker {
    pub symbol: [u8; 16],
    pub symbol_len: u8,
    pub bid_price: f64,
    pub ask_price: f64,
    pub bid_qty: f64,
    pub ask_qty: f64,
    pub time: i64, // –±–∏—Ä–∂–µ–≤–æ–π timestamp
}

impl CBookTicker {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }
}
```

#### Trade (–ª–µ–Ω—Ç–∞ —Å–¥–µ–ª–æ–∫)

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct CTrade {
    pub symbol: [u8; 16],
    pub symbol_len: u8,
    pub price: f64,
    pub qty: f64,   // –≤ —ç—Ç–æ–π —Å–∏—Å—Ç–µ–º–µ: qty < 0.0 => –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π SELL, qty > 0.0 => –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã–π BUY
    pub time: i64,  // –±–∏—Ä–∂–µ–≤–æ–π timestamp
}

impl CTrade {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }
}
```

### –ö–æ–Ω—Ñ–∏–≥ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StrategyConfig {
    pub symbol: [u8; 16],           // –Ω–∞–ø—Ä–∏–º–µ—Ä, "SOLUSDT"
    pub symbol_len: u8,
    pub params_json: *const c_char, // JSON-—Å—Ç—Ä–æ–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
}

impl StrategyConfig {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }

    /// –ü–∞—Ä—Å–∏–Ω–≥ JSON-–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É (serde)
    pub fn parse_params<T: serde::de::DeserializeOwned>(&self) -> Result<T, serde_json::Error> {
        if self.params_json.is_null() {
            return serde_json::from_str("{}");
        }
        unsafe {
            let c_str = std::ffi::CStr::from_ptr(self.params_json);
            let json_str = c_str.to_str().unwrap_or("{}");
            serde_json::from_str(json_str)
        }
    }
}
```

–û–±—ã—á–Ω–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –æ–ø–∏—Å—ã–≤–∞–µ—Ç —Å–≤–æ–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–∞–∫:

```rust
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
struct StrategyParams {
    #[serde(default = "default_order_size")]
    order_size_usd: f64,
    #[serde(default)]
    api_key: String,
    #[serde(default)]
    secret_key: String,
    // ... –¥—Ä—É–≥–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã ...
}

fn default_order_size() -> f64 { 100.0 }
```

–ò –≤ `run`:

```rust
let params: StrategyParams = config
    .parse_params()
    .unwrap_or_else(|_| StrategyParams::default());
```

### –†–∞–±–æ—Ç–∞ —Å –æ—Ä–¥–µ—Ä–∞–º–∏

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct OrderResult {
    pub success: bool,
    pub order_id: i64,
    pub error_code: i32,
}

pub type OrderCallback = unsafe extern "C" fn(result: OrderResult);
```

#### –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–æ–≤

```rust
// order_type: 0 = LIMIT, 1 = MARKET
pub type PlaceOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    price: f64,         // –¥–ª—è MARKET –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è
    quantity: f64,
    side: *const c_char, // "BUY" / "SELL"
    order_type: u8,       // 0 = LIMIT, 1 = MARKET
    callback: OrderCallback,
);
```

- –§—É–Ω–∫—Ü–∏—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è: –æ–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É, —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –æ—Ç–≤–µ—Ç –æ—Ç –±–∏—Ä–∂–∏ –ø—Ä–∏—Ö–æ–¥–∏—Ç –ø–æ–∑–∂–µ —á–µ—Ä–µ–∑ `callback`.
- –°—Ç—Ä–∞—Ç–µ–≥–∏—è –¥–æ–ª–∂–Ω–∞ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å C‚Äë—Å—Ç—Ä–æ–∫–∏ (`CString`) –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –∫–æ–ª–ª–±—ç–∫–µ.

#### –û—Ç–º–µ–Ω–∞ –æ—Ä–¥–µ—Ä–∞

```rust
pub type CancelOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    order_id: i64,
    callback: OrderCallback,
);
```

---

## –ö–∞–∫ –æ–±—ã—á–Ω–æ –≤—ã–≥–ª—è–¥–∏—Ç `run`

–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–∫–µ–ª–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;
use std::ffi::CString;

use crossbeam::channel::Receiver;
use serde::Deserialize;

static SHOULD_STOP: AtomicBool = AtomicBool::new(false);

#[derive(Debug, Clone, Deserialize)]
struct StrategyParams {
    #[serde(default = "default_order_size")]
    order_size_usd: f64,
    #[serde(default)]
    api_key: String,
    #[serde(default)]
    secret_key: String,
}

fn default_order_size() -> f64 { 100.0 }

unsafe extern "C" fn on_order_placed(result: OrderResult) {
    if result.success {
        println!("Order placed, id={}", result.order_id);
    } else {
        println!("Order failed, code={}", result.error_code);
    }
}

#[no_mangle]
pub extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,
    place_order: PlaceOrderFn,
    _cancel_order: CancelOrderFn,
    config: StrategyConfig,
) -> i32 {
    SHOULD_STOP.store(false, Ordering::Relaxed);

    let rx = unsafe { &*rx_ptr };
    let symbol = config.symbol_str().to_string();

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ JSON
    let params: StrategyParams = config
        .parse_params()
        .unwrap_or_else(|_| StrategyParams::default());

    println!("Strategy started on {}", symbol);
    println!("Params: {:?}", params);

    while !SHOULD_STOP.load(Ordering::Relaxed) {
        match rx.recv_timeout(Duration::from_millis(10)) {
            Ok(event) => {
                match event.event_type {
                    0 => {
                        // BookTicker
                        let bt = unsafe { event.data.book_ticker };
                        if !bt.symbol_str().eq_ignore_ascii_case(&symbol) {
                            continue;
                        }
                        // –∑–¥–µ—Å—å –ª–æ–≥–∏–∫–∞ –ø–æ bid/ask
                    }
                    1 => {
                        // Trade
                        let tr = unsafe { event.data.trade };
                        if !tr.symbol_str().eq_ignore_ascii_case(&symbol) {
                            continue;
                        }
                        // –∑–¥–µ—Å—å –ª–æ–≥–∏–∫–∞ –ø–æ —Ç—Ä–µ–π–¥–∞–º (qty < 0 = sell)
                    }
                    _ => {}
                }
            }
            Err(_) => {
                // timeout ‚Äî –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
            }
        }

        // –ü—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ ‚Äî –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞:
        // let api_key = CString::new(params.api_key.as_str()).unwrap();
        // let secret_key = CString::new(params.secret_key.as_str()).unwrap();
        // let symbol_c = CString::new(symbol.as_str()).unwrap();
        // let side = CString::new("BUY").unwrap();
        // let order_type: u8 = 0; // LIMIT –∏–ª–∏ 1 –¥–ª—è MARKET
        // let price = ...;
        // let qty = ...;
        // unsafe {
        //     place_order(
        //         api_key.as_ptr(),
        //         secret_key.as_ptr(),
        //         symbol_c.as_ptr(),
        //         price,
        //         qty,
        //         side.as_ptr(),
        //         order_type,
        //         on_order_placed,
        //     );
        // }
    }

    println!("Strategy stopped");
    0
}

#[no_mangle]
pub extern "C" fn stop() {
    SHOULD_STOP.store(true, Ordering::Relaxed);
}
```

---

## –ü—Ä–∞–≤–∏–ª–∞ / –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –¥–ª—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π

- –°—Ç—Ä–∞—Ç–µ–≥–∏—è **–æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω–∞—è**: `run` –∫—Ä—É—Ç–∏—Ç—Å—è –≤ –æ–¥–Ω–æ–º –ø–æ—Ç–æ–∫–µ, –Ω–æ:
  - –∫–æ–ª–ª–±–µ–∫–∏ `OrderCallback` –≤—ã–∑—ã–≤–∞—é—Ç—Å—è –∏–∑ –¥—Ä—É–≥–∏—Ö –ø–æ—Ç–æ–∫–æ–≤ ‚Üí –æ–±—â–∏–π —Å—Ç–µ–π—Ç –Ω—É–∂–Ω–æ –∑–∞—â–∏—â–∞—Ç—å (`Atomic*`, `Mutex` –∏ —Ç.–ø.).
- –ù–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –¥–æ–ª–≥–æ –≤–Ω—É—Ç—Ä–∏ —Ü–∏–∫–ª–∞ `run` (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `recv_timeout` —Å –∫–æ—Ä–æ—Ç–∫–∏–º —Ç–∞–π–º–∞—É—Ç–æ–º).
- –î–ª—è —Å—Ç—Ä–æ–∫ –≤ FFI:
  - –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –≤—Å–µ–≥–¥–∞ —Å–æ–∑–¥–∞–≤–∞—Ç—å `CString`,
  - –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å `as_ptr()` –≤ `place_order` / `cancel_order`.
- –î–ª—è union `event.data` –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –≤–µ—Ç–∫—É –ø–æ `event_type` –∏ `unsafe`.

---

–≠—Ç—É –∑–∞–≥–æ—Ç–æ–≤–∫—É –º–æ–∂–Ω–æ –¥–∞–≤–∞—Ç—å –¥—Ä—É–≥–∏–º –º–æ–¥–µ–ª—è–º –∫–∞–∫ –æ–ø–∏—Å–∞–Ω–∏–µ —Å—Ä–µ–¥—ã: –∫–∞–∫–∏–µ —Ç–∏–ø—ã –¥–æ—Å—Ç—É–ø–Ω—ã, –∫–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç `run/stop`, –∫–∞–∫ –ø—Ä–∏—Ö–æ–¥—è—Ç –¥–∞–Ω–Ω—ã–µ (bookticker/trades) –∏ –∫–∞–∫ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –ª–∏–º–∏—Ç/–º–∞—Ä–∫–µ—Ç –æ—Ä–¥–µ—Ä–∞.




{
  "id": "funding_collector",
  "name": "Funding Collector",
  "symbol": "SOLUSDT",
  "code": "use crossbeam::channel::Receiver;\nuse serde::Deserialize;\nuse std::ffi::CString;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::time::Duration;\n\nuse chrono::{Local, TimeZone, Duration as ChronoDuration};\n\nstatic STOP_FLAG: AtomicBool = AtomicBool::new(false);\n\n#[derive(Debug, Clone, Deserialize)]\nstruct StrategyParams {\n    order_qty: f64,\n    target_hour: u8,\n    target_minute: u8,\n    #[serde(default = \"default_pre_seconds\")]\n    pre_seconds: u64,\n    #[serde(default = \"default_exit_delay_ms\")]\n    exit_delay_ms: u64,\n    #[serde(default)]\n    repeat: bool,\n    #[serde(default)]\n    api_key: String,\n    #[serde(default)]\n    secret_key: String,\n}\n\nfn default_pre_seconds() -> u64 { 5 }\nfn default_exit_delay_ms() -> u64 { 1 }\n\nimpl Default for StrategyParams {\n    fn default() -> Self {\n        Self {\n            order_qty: 0.0,\n            target_hour: 0,\n            target_minute: 0,\n            pre_seconds: default_pre_seconds(),\n            exit_delay_ms: default_exit_delay_ms(),\n            repeat: false,\n            api_key: String::new(),\n            secret_key: String::new(),\n        }\n    }\n}\n\nunsafe extern \"C\" fn on_entry_placed(result: OrderResult) {\n    if result.success {\n        println!(\"‚úÖ ENTRY order placed, id={}\", result.order_id);\n    } else {\n        println!(\"‚ùå ENTRY order failed, code={}\", result.error_code);\n    }\n}\n\nunsafe extern \"C\" fn on_exit_placed(result: OrderResult) {\n    if result.success {\n        println!(\"‚úÖ EXIT order placed, id={}\", result.order_id);\n    } else {\n        println!(\"‚ùå EXIT order failed, code={}\", result.error_code);\n    }\n}\n\nfn compute_next_times(\n    now: chrono::DateTime<Local>,\n    hour: u8,\n    minute: u8,\n    pre_seconds: u64,\n    exit_delay_ms: u64,\n) -> (chrono::DateTime<Local>, chrono::DateTime<Local>) {\n    let today = now.date_naive();\n    let mut target_naive = today\n        .and_hms_opt(hour as u32, minute as u32, 0)\n        .unwrap_or_else(|| today.and_hms_opt(0, 0, 0).unwrap());\n\n    let mut target = Local.from_local_datetime(&target_naive).unwrap();\n\n    if target <= now {\n        target_naive = (today + ChronoDuration::days(1))\n            .and_hms_opt(hour as u32, minute as u32, 0)\n            .unwrap();\n        target = Local.from_local_datetime(&target_naive).unwrap();\n    }\n\n    let entry_time = target - ChronoDuration::seconds(pre_seconds as i64);\n    let exit_time = target + ChronoDuration::milliseconds(exit_delay_ms as i64);\n\n    (entry_time, exit_time)\n}\n\n#[no_mangle]\npub extern \"C\" fn run(\n    rx_ptr: *mut Receiver<CEvent>,\n    place_order: PlaceOrderFn,\n    _cancel_order: CancelOrderFn,\n    config: StrategyConfig,\n) -> i32 {\n    STOP_FLAG.store(false, Ordering::Relaxed);\n\n    let rx = unsafe { &*rx_ptr };\n    let symbol = config.symbol_str().to_string();\n\n    let params: StrategyParams = config\n        .parse_params()\n        .unwrap_or_else(|e| {\n            println!(\"‚ö†Ô∏è Failed to parse params: {e}, using defaults\");\n            StrategyParams::default()\n        });\n\n    println!(\"üöÄ Funding Collector started\");\n    println!(\"   Symbol: {}\", symbol);\n    println!(\"   Params: {:?}\", params);\n\n    if params.order_qty <= 0.0 {\n        println!(\"‚ö†Ô∏è order_qty <= 0, strategy will not trade\");\n    }\n    if params.api_key.is_empty() || params.secret_key.is_empty() {\n        println!(\"‚ö†Ô∏è api_key / secret_key are empty, strategy will not place orders\");\n    }\n\n    let api_key_c = CString::new(params.api_key.clone()).unwrap_or_else(|_| CString::new(\"\").unwrap());\n    let secret_key_c = CString::new(params.secret_key.clone()).unwrap_or_else(|_| CString::new(\"\").unwrap());\n    let symbol_c = CString::new(symbol.clone()).unwrap();\n    let buy_side_c = CString::new(\"BUY\").unwrap();\n    let sell_side_c = CString::new(\"SELL\").unwrap();\n\n    let mut now = Local::now();\n    let (mut entry_time, mut exit_time) = compute_next_times(\n        now,\n        params.target_hour,\n        params.target_minute,\n        params.pre_seconds,\n        params.exit_delay_ms,\n    );\n\n    println!(\n        \"üïí Next funding target at {:02}:{:02}, entry at {}, exit at {}\",\n        params.target_hour,\n        params.target_minute,\n        entry_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n        exit_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n    );\n\n    let mut entry_sent = false;\n    let mut exit_sent = false;\n\n    while !STOP_FLAG.load(Ordering::Relaxed) {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(_) => {}\n            Err(crossbeam::channel::RecvTimeoutError::Timeout) => {}\n            Err(_) => {\n                println!(\"‚ö†Ô∏è Event channel closed\");\n                break;\n            }\n        }\n\n        now = Local::now();\n\n        if !entry_sent && now >= entry_time && now < exit_time {\n            if params.order_qty > 0.0 && !params.api_key.is_empty() && !params.secret_key.is_empty() {\n                println!(\n                    \"üì• ENTRY: sending MARKET BUY {} {} at {}\",\n                    params.order_qty,\n                    symbol,\n                    now.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                );\n                unsafe {\n                    place_order(\n                        api_key_c.as_ptr(),\n                        secret_key_c.as_ptr(),\n                        symbol_c.as_ptr(),\n                        0.0,\n                        params.order_qty,\n                        buy_side_c.as_ptr(),\n                        1,\n                        on_entry_placed,\n                    );\n                }\n                entry_sent = true;\n            } else {\n                println!(\"‚ö†Ô∏è ENTRY conditions not met, skipping\");\n                entry_sent = true;\n            }\n        }\n\n        if entry_sent && !exit_sent && now >= exit_time {\n            if params.order_qty > 0.0 && !params.api_key.is_empty() && !params.secret_key.is_empty() {\n                println!(\n                    \"üì§ EXIT: sending MARKET SELL {} {} at {}\",\n                    params.order_qty,\n                    symbol,\n                    now.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                );\n                unsafe {\n                    place_order(\n                        api_key_c.as_ptr(),\n                        secret_key_c.as_ptr(),\n                        symbol_c.as_ptr(),\n                        0.0,\n                        params.order_qty,\n                        sell_side_c.as_ptr(),\n                        1,\n                        on_exit_placed,\n                    );\n                }\n                exit_sent = true;\n            } else {\n                println!(\"‚ö†Ô∏è EXIT conditions not met, skipping\");\n                exit_sent = true;\n            }\n\n            if params.repeat {\n                now = Local::now();\n                let (new_entry, new_exit) = compute_next_times(\n                    now,\n                    params.target_hour,\n                    params.target_minute,\n                    params.pre_seconds,\n                    params.exit_delay_ms,\n                );\n                entry_time = new_entry;\n                exit_time = new_exit;\n                entry_sent = false;\n                exit_sent = false;\n\n                println!(\n                    \"üîÅ Next cycle: entry at {}, exit at {}\",\n                    entry_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                    exit_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                );\n            } else {\n                println!(\"‚úÖ One-shot mode: finished after first funding cycle\");\n                break;\n            }\n        }\n    }\n\n    println!(\"üõë Funding Collector stopped\");\n    0\n}\n\n#[no_mangle]\npub extern \"C\" fn stop() {\n    println!(\"üõë Stop signal received\");\n    STOP_FLAG.store(true, Ordering::Relaxed);\n}\n"
}