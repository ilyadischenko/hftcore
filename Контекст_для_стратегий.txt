–í–æ—Ç –∏–¥–µ–∞–ª—å–Ω–∞—è **"–°–∏—Å—Ç–µ–º–Ω–∞—è –ø–æ–¥—Å–∫–∞–∑–∫–∞" (System Prompt)** –¥–ª—è –Ω–µ–π—Ä–æ—Å–µ—Ç–∏.

–¢—ã –º–æ–∂–µ—à—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ç–µ–∫—Å—Ç –∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –µ–≥–æ –ª—é–±–æ–π LLM (ChatGPT, Claude, DeepSeek). –û–Ω —Å–æ–¥–µ—Ä–∂–∏—Ç **–∫–æ–Ω—Ç—Ä–∞–∫—Ç –¥–∞–Ω–Ω—ã—Ö**, —Å–∏–≥–Ω–∞—Ç—É—Ä—ã —Ñ—É–Ω–∫—Ü–∏–π –∏ –ø—Ä–∞–≤–∏–ª–∞ –Ω–∞–ø–∏—Å–∞–Ω–∏—è –∫–æ–¥–∞, –Ω–æ –±–µ–∑ "–≤–æ–¥—ã".

---

### üìã –¢–µ–∫—Å—Ç –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è –≤ –Ω–µ–π—Ä–æ—Å–µ—Ç—å:

```markdown
–Ø –ø–∏—à—É HFT-—Å—Ç—Ä–∞—Ç–µ–≥–∏—é –Ω–∞ Rust, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –∫–∞–∫ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ (DLL/dylib).
–°–∏—Å—Ç–µ–º–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É Zero-Copy FFI. –î–∞–Ω–Ω—ã–µ –ø—Ä–∏—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª `crossbeam`.

–¢–≤–æ—è –∑–∞–¥–∞—á–∞ ‚Äî –Ω–∞–ø–∏—Å–∞—Ç—å –∫–æ–¥ —Ñ—É–Ω–∫—Ü–∏–∏ `run`.

### 1. –ö–æ–Ω—Ç–µ–∫—ÅÔøΩÔøΩ –∏ –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö (–¥–æ—Å—Ç—É–ø–Ω—ã –≤ `types.rs`)
–≠—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã, –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å –∏—Ö –Ω–µ –Ω—É–∂–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–π –∏—Ö –∫–∞–∫ –µ—Å—Ç—å.

```rust
// –û–°–ù–û–í–ù–û–ï –°–û–ë–´–¢–ò–ï
#[repr(C)]
pub struct CEvent {
    pub event_type: u8, // 0=BookTicker, 1=Trade, 2=Order, 3=Account
    pub data: CEventData, // Union
    pub received_at_ns: u64,
}

#[repr(C)]
pub union CEventData {
    pub book_ticker: CBookTicker,
    pub trade: CTrade,
    pub order: COrderUpdate,
    pub account: CAccountUpdate,
}

// –•–ï–õ–ü–ï–†–´ (–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ union)
impl CEvent {
    pub fn as_book_ticker(&self) -> Option<&CBookTicker>;
    pub fn as_trade(&self) -> Option<&CTrade>;
    pub fn as_order(&self) -> Option<&COrderUpdate>;
    pub fn as_account(&self) -> Option<&CAccountUpdate>;
}

// –î–ê–ù–ù–´–ï –û–†–î–ï–†–ê (User Data)
#[repr(C)]
pub struct COrderUpdate {
    pub order_id: i64,
    pub price: f64,
    pub qty: f64,
    pub accumulated_qty: f64, // filled qty
    pub commission: f64,
    // Char codes: 'N'=New, 'P'=Partial, 'F'=Filled, 'C'=Canceled
    pub status_char: u8, 
    // Char codes: 'B'=Buy, 'S'=Sell
    pub side_char: u8, 
    pub event_time: i64,
    // –ú–µ—Ç–æ–¥—ã –¥–æ—Å—Ç—É–ø–∞ –∫ —Å—Ç—Ä–æ–∫–∞–º (–≤–æ–∑–≤—Ä–∞—â–∞—é—Ç &str)
    pub fn symbol(&self) -> &str;
    pub fn client_id(&self) -> &str;
}

// –†–´–ù–û–ß–ù–´–ï –î–ê–ù–ù–´–ï
#[repr(C)]
pub struct CBookTicker {
    pub bid_price: f64; pub ask_price: f64;
    pub bid_qty: f64;   pub ask_qty: f64;
    pub fn symbol(&self) -> &str;
}

// –ë–ê–õ–ê–ù–°
#[repr(C)]
pub struct CAccountUpdate {
    pub reason_code: u8; // 3=Order, 4=FundingFee
    pub balances: [CBalanceItem; 10];
    pub balances_count: u8;
}
pub struct CBalanceItem {
    pub wallet_balance: f64; pub balance_change: f64;
    pub fn asset(&self) -> &str;
}
```

### 2. –§—É–Ω–∫—Ü–∏–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è (Execution)

```rust
// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–æ–Ω—Ñ–∏–≥–∞
pub struct StrategyConfig {
    pub fn symbol(&self) -> &str;
    pub fn should_stop(&self) -> bool; // –ü—Ä–æ–≤–µ—Ä—è—Ç—å –≤ —Ü–∏–∫–ª–µ!
    pub fn params_str(&self) -> &str;  // JSON —Å—Ç—Ä–æ–∫–∞ —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
}

// –ö–æ–ª–ª–±—ç–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
pub struct OrderResult { pub success: bool; pub order_id: i64; pub error_code: i32; }

// –°–∏–≥–Ω–∞—Ç—É—Ä—ã —Ñ—É–Ω–∫—Ü–∏–π (–ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ run)
type PlaceOrderFn = unsafe extern "C" fn(
    api_key: *const c_char, secret_key: *const c_char, symbol: *const c_char,
    price: f64, qty: f64, side: *const c_char, order_type: u8, // 0=Limit, 1=Market
    cb: unsafe extern "C" fn(OrderResult)
);

type CancelOrderFn = unsafe extern "C" fn(
    api_key: *const c_char, secret_key: *const c_char, symbol: *const c_char,
    id: i64, cb: unsafe extern "C" fn(OrderResult)
);
```

### 3. –®–∞–±–ª–æ–Ω —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ (Boilerplate)

–ü–∏—à–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é, –∏—Å–ø–æ–ª—å–∑—É—è —ç—Ç–æ—Ç —à–∞–±–ª–æ–Ω.
**–í–∞–∂–Ω–æ:**
1. –ò—Å–ø–æ–ª—å–∑—É–π `crossbeam::channel`.
2. –ù–µ –∏—Å–ø–æ–ª—å–∑—É–π `String` –∏–ª–∏ –∞–ª–ª–æ–∫–∞—Ü–∏–∏ –≤ –≥–æ—Ä—è—á–µ–º —Ü–∏–∫–ª–µ `loop`.
3. `side` –¥–ª—è –æ—Ä–¥–µ—Ä–∞ –ø–µ—Ä–µ–¥–∞–≤–∞–π –∫–∞–∫ C-string: `b"BUY\0".as_ptr() as *const c_char`.

```rust
use crossbeam::channel::{Receiver, RecvTimeoutError};
use std::time::Duration;
use std::ffi::{c_char, CString};
use serde::Deserialize;

// –¢–≤–æ–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (–ø–∞—Ä—Å—è—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ)
#[derive(Deserialize)]
struct Params {
    api_key: String,
    secret_key: String,
    qty: f64,
}

#[no_mangle]
pub unsafe extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,
    place_order: PlaceOrderFn,
    cancel_order: CancelOrderFn,
    config: StrategyConfig
) -> i32 {
    // 1. –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    let rx = &*rx_ptr; // –ü—Ä–µ–≤—Ä–∞—â–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å –≤ —Å—Å—ã–ª–∫—É
    let params: Params = serde_json::from_str(config.params_str()).unwrap_or(/* defaults */);
    
    // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ C-—Å—Ç—Ä–æ–∫ –¥–ª—è –æ—Ä–¥–µ—Ä–æ–≤ (—á—Ç–æ–±—ã –Ω–µ –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≤ —Ü–∏–∫–ª–µ)
    let api_key = CString::new(params.api_key).unwrap();
    let secret_key = CString::new(params.secret_key).unwrap();
    let symbol = CString::new(config.symbol()).unwrap();
    let side_buy = CString::new("BUY").unwrap();
    let side_sell = CString::new("SELL").unwrap();

    println!("üöÄ Strategy started for {}", config.symbol());

    // 2. –ì–ª–∞–≤–Ω—ã–π —Ü–∏–∫–ª
    loop {
        if config.should_stop() { break; }

        match rx.recv_timeout(Duration::from_millis(10)) {
            Ok(event) => {
                match event.event_type {
                    0 => { // BookTicker
                        if let Some(bt) = event.as_book_ticker() {
                            // –¢–í–û–Ø –õ–û–ì–ò–ö–ê –ó–î–ï–°–¨
                        }
                    },
                    1 => { /* Trade */ },
                    2 => { // Order Update
                        if let Some(o) = event.as_order() {
                            println!("Order update: ID={} Status={}", o.order_id, o.status_char as char);
                        }
                    },
                    3 => { /* Account */ },
                    _ => {}
                }
            },
            Err(RecvTimeoutError::Timeout) => continue, // –ü—Ä–æ–≤–µ—Ä—è–µ–º stop flag
            Err(_) => break, // –ö–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç
        }
    }
    0
}

// –ö–æ–ª–ª–±—ç–∫ –¥–ª—è –æ—Ä–¥–µ—Ä–æ–≤ (–æ–±—è–∑–∞—Ç–µ–ª–µ–Ω, –µ—Å–ª–∏ —Ç–æ—Ä–≥—É–µ—à—å)
unsafe extern "C" fn on_order_result(res: OrderResult) {
    if !res.success {
        println!("Order failed: code={}", res.error_code);
    }
}
```

### –ó–∞–¥–∞–Ω–∏–µ –¥–ª—è —Ç–µ–±—è:
–ù–∞–ø–∏—à–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—é, –∫–æ—Ç–æ—Ä–∞—è... (–û–ü–ò–®–ò –°–í–û–Æ –õ–û–ì–ò–ö–£ –ó–î–ï–°–¨)
```


{
  "id": "funding_collector",
  "name": "Funding Collector",
  "symbol": "SOLUSDT",
  "code": "mod types;\nuse types::*;\n\nuse crossbeam::channel::Receiver;\nuse serde::Deserialize;\nuse std::ffi::CString;\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::sync::OnceLock;\nuse std::time::Duration;\n\nuse chrono::{Local, TimeZone, Duration as ChronoDuration};\n\nstatic STOP_FLAG: AtomicBool = AtomicBool::new(false);\n\nstatic API_KEY_C: OnceLock<CString> = OnceLock::new();\nstatic SECRET_KEY_C: OnceLock<CString> = OnceLock::new();\nstatic SYMBOL_C: OnceLock<CString> = OnceLock::new();\nstatic BUY_SIDE_C: OnceLock<CString> = OnceLock::new();\nstatic SELL_SIDE_C: OnceLock<CString> = OnceLock::new();\n\n#[derive(Debug, Clone, Deserialize)]\nstruct StrategyParams {\n    order_qty: f64,\n    target_hour: u8,\n    target_minute: u8,\n    #[serde(default = \"default_pre_seconds\")]\n    pre_seconds: u64,\n    #[serde(default = \"default_exit_delay_ms\")]\n    exit_delay_ms: u64,\n    #[serde(default)]\n    repeat: bool,\n    #[serde(default)]\n    api_key: String,\n    #[serde(default)]\n    secret_key: String,\n}\n\nfn default_pre_seconds() -> u64 { 5 }\nfn default_exit_delay_ms() -> u64 { 1 }\n\nimpl Default for StrategyParams {\n    fn default() -> Self {\n        Self {\n            order_qty: 0.0,\n            target_hour: 0,\n            target_minute: 0,\n            pre_seconds: default_pre_seconds(),\n            exit_delay_ms: default_exit_delay_ms(),\n            repeat: false,\n            api_key: String::new(),\n            secret_key: String::new(),\n        }\n    }\n}\n\nunsafe extern \"C\" fn on_entry_placed(result: OrderResult) {\n    println!(\"üîî on_entry_placed CALLBACK STARTED\");\n    if result.success {\n        println!(\"‚úÖ ENTRY order placed, id={}\", result.order_id);\n    } else {\n        println!(\"‚ùå ENTRY order failed, code={}\", result.error_code);\n    }\n    println!(\"üîî on_entry_placed CALLBACK FINISHED\");\n}\n\nunsafe extern \"C\" fn on_exit_placed(result: OrderResult) {\n    println!(\"üîî on_exit_placed CALLBACK STARTED\");\n    if result.success {\n        println!(\"‚úÖ EXIT order placed, id={}\", result.order_id);\n    } else {\n        println!(\"‚ùå EXIT order failed, code={}\", result.error_code);\n    }\n    println!(\"üîî on_exit_placed CALLBACK FINISHED\");\n}\n\nfn compute_next_times(\n    now: chrono::DateTime<Local>,\n    hour: u8,\n    minute: u8,\n    pre_seconds: u64,\n    exit_delay_ms: u64,\n) -> (chrono::DateTime<Local>, chrono::DateTime<Local>) {\n    let today = now.date_naive();\n    let mut target_naive = today\n        .and_hms_opt(hour as u32, minute as u32, 0)\n        .unwrap_or_else(|| today.and_hms_opt(0, 0, 0).unwrap());\n\n    let mut target = Local.from_local_datetime(&target_naive).unwrap();\n\n    if target <= now {\n        target_naive = (today + ChronoDuration::days(1))\n            .and_hms_opt(hour as u32, minute as u32, 0)\n            .unwrap();\n        target = Local.from_local_datetime(&target_naive).unwrap();\n    }\n\n    let entry_time = target - ChronoDuration::seconds(pre_seconds as i64);\n    let exit_time = target + ChronoDuration::milliseconds(exit_delay_ms as i64);\n\n    (entry_time, exit_time)\n}\n\nfn init_static_strings(api_key: &str, secret_key: &str, symbol: &str) -> bool {\n    let api_result = API_KEY_C.get_or_init(|| {\n        CString::new(api_key).unwrap_or_else(|_| CString::new(\"\").unwrap())\n    });\n    \n    let secret_result = SECRET_KEY_C.get_or_init(|| {\n        CString::new(secret_key).unwrap_or_else(|_| CString::new(\"\").unwrap())\n    });\n    \n    let symbol_result = SYMBOL_C.get_or_init(|| {\n        CString::new(symbol).unwrap_or_else(|_| CString::new(\"\").unwrap())\n    });\n    \n    BUY_SIDE_C.get_or_init(|| CString::new(\"BUY\").unwrap());\n    SELL_SIDE_C.get_or_init(|| CString::new(\"SELL\").unwrap());\n    \n    if !api_key.is_empty() && api_result.as_bytes().is_empty() {\n        return false;\n    }\n    if !secret_key.is_empty() && secret_result.as_bytes().is_empty() {\n        return false;\n    }\n    if !symbol.is_empty() && symbol_result.as_bytes().is_empty() {\n        return false;\n    }\n    \n    true\n}\n\n#[no_mangle]\npub extern \"C\" fn run(\n    rx_ptr: *mut Receiver<CEvent>,\n    place_order: PlaceOrderFn,\n    _cancel_order: CancelOrderFn,\n    config: StrategyConfig,\n) -> i32 {\n    STOP_FLAG.store(false, Ordering::Relaxed);\n\n    if rx_ptr.is_null() {\n        println!(\"‚ùå ERROR: rx_ptr is null!\");\n        return -1;\n    }\n\n    let rx = unsafe { &*rx_ptr };\n    let symbol = config.symbol_str().to_string();\n\n    let params: StrategyParams = config\n        .parse_params()\n        .unwrap_or_else(|e| {\n            println!(\"‚ö†Ô∏è Failed to parse params: {e}, using defaults\");\n            StrategyParams::default()\n        });\n\n    println!(\"üöÄ Funding Collector started\");\n    println!(\"   Symbol: {}\", symbol);\n    println!(\"   Params: {:?}\", params);\n\n    if params.order_qty <= 0.0 {\n        println!(\"‚ö†Ô∏è order_qty <= 0, strategy will not trade\");\n    }\n    if params.api_key.is_empty() || params.secret_key.is_empty() {\n        println!(\"‚ö†Ô∏è api_key / secret_key are empty, strategy will not place orders\");\n    }\n\n    if !init_static_strings(&params.api_key, &params.secret_key, &symbol) {\n        println!(\"‚ùå ERROR: Failed to initialize static strings!\");\n        return -2;\n    }\n\n    let api_key_ptr = API_KEY_C.get().unwrap().as_ptr();\n    let secret_key_ptr = SECRET_KEY_C.get().unwrap().as_ptr();\n    let symbol_ptr = SYMBOL_C.get().unwrap().as_ptr();\n    let buy_side_ptr = BUY_SIDE_C.get().unwrap().as_ptr();\n    let sell_side_ptr = SELL_SIDE_C.get().unwrap().as_ptr();\n\n    println!(\"‚úÖ Static strings initialized successfully\");\n\n    let mut now = Local::now();\n    let (mut entry_time, mut exit_time) = compute_next_times(\n        now,\n        params.target_hour,\n        params.target_minute,\n        params.pre_seconds,\n        params.exit_delay_ms,\n    );\n\n    println!(\n        \"üïí Next funding target at {:02}:{:02}, entry at {}, exit at {}\",\n        params.target_hour,\n        params.target_minute,\n        entry_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n        exit_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n    );\n\n    let mut entry_sent = false;\n    let mut exit_sent = false;\n\n    while !STOP_FLAG.load(Ordering::Relaxed) {\n        match rx.recv_timeout(Duration::from_millis(100)) {\n            Ok(_event) => {\n                println!(\"üì® Received event\");\n            }\n            Err(crossbeam::channel::RecvTimeoutError::Timeout) => {}\n            Err(crossbeam::channel::RecvTimeoutError::Disconnected) => {\n                println!(\"‚ö†Ô∏è Event channel disconnected\");\n                break;\n            }\n        }\n\n        now = Local::now();\n\n        if !entry_sent && now >= entry_time && now < exit_time {\n            println!(\"‚è∞ ENTRY time reached: {}\", now.format(\"%Y-%m-%d %H:%M:%S%.3f\"));\n            \n            if params.order_qty > 0.0 \n                && !params.api_key.is_empty() \n                && !params.secret_key.is_empty() \n            {\n                println!(\n                    \"üì• ENTRY: sending MARKET BUY {} {} at {}\",\n                    params.order_qty,\n                    symbol,\n                    now.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                );\n                \n                println!(\"üîÑ Calling place_order for ENTRY...\");\n                unsafe {\n                    place_order(\n                        api_key_ptr,\n                        secret_key_ptr,\n                        symbol_ptr,\n                        0.0,\n                        params.order_qty,\n                        buy_side_ptr,\n                        1,\n                        on_entry_placed,\n                    );\n                }\n                println!(\"‚úÖ place_order for ENTRY returned\");\n                \n                entry_sent = true;\n            } else {\n                println!(\"‚ö†Ô∏è ENTRY conditions not met, skipping\");\n                entry_sent = true;\n            }\n        }\n\n        if entry_sent && !exit_sent && now >= exit_time {\n            println!(\"‚è∞ EXIT time reached: {}\", now.format(\"%Y-%m-%d %H:%M:%S%.3f\"));\n            \n            if params.order_qty > 0.0 \n                && !params.api_key.is_empty() \n                && !params.secret_key.is_empty() \n            {\n                println!(\n                    \"üì§ EXIT: sending MARKET SELL {} {} at {}\",\n                    params.order_qty,\n                    symbol,\n                    now.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                );\n                \n                println!(\"üîÑ Calling place_order for EXIT...\");\n                unsafe {\n                    place_order(\n                        api_key_ptr,\n                        secret_key_ptr,\n                        symbol_ptr,\n                        0.0,\n                        params.order_qty,\n                        sell_side_ptr,\n                        1,\n                        on_exit_placed,\n                    );\n                }\n                println!(\"‚úÖ place_order for EXIT returned\");\n                \n                exit_sent = true;\n            } else {\n                println!(\"‚ö†Ô∏è EXIT conditions not met, skipping\");\n                exit_sent = true;\n            }\n\n            println!(\"‚è≥ Waiting for callback to complete...\");\n            std::thread::sleep(Duration::from_millis(500));\n\n            if params.repeat {\n                now = Local::now();\n                let (new_entry, new_exit) = compute_next_times(\n                    now,\n                    params.target_hour,\n                    params.target_minute,\n                    params.pre_seconds,\n                    params.exit_delay_ms,\n                );\n                entry_time = new_entry;\n                exit_time = new_exit;\n                entry_sent = false;\n                exit_sent = false;\n\n                println!(\n                    \"üîÅ Next cycle: entry at {}, exit at {}\",\n                    entry_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                    exit_time.format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                );\n            } else {\n                println!(\"‚úÖ One-shot mode: waiting before exit...\");\n                std::thread::sleep(Duration::from_secs(2));\n                println!(\"‚úÖ One-shot mode: finished after first funding cycle\");\n                break;\n            }\n        }\n    }\n\n    println!(\"‚è≥ Final wait for pending callbacks...\");\n    std::thread::sleep(Duration::from_secs(1));\n    \n    println!(\"üõë Funding Collector stopped\");\n    0\n}\n\n#[no_mangle]\npub extern \"C\" fn stop() {\n    println!(\"üõë Stop signal received\");\n    STOP_FLAG.store(true, Ordering::Relaxed);\n}"
}



