Ниже заготовка‑описание среды, которую можно давать другим нейросетям, чтобы они понимали, как писать стратегии под твоё ядро. Она короткая, но с нужным контекстом и списком доступных инструментов.

---

## Контекст: как устроены стратегии

- Стратегия — это отдельная Rust‑библиотека (`cdylib`) с файлом `src/lib.rs`.
- В начале `lib.rs` **уже** добавляется:

  ```rust
  mod types;
  use types::*;
  ```

  Модуль `types` сгенерирован ядром и содержит все FFI‑типы и функции, доступные стратегии.

- Ядро загружает стратегию как `.so/.dll` и вызывает два экспортированных метода:

  ```rust
  #[no_mangle]
  pub extern "C" fn run(
      rx: *mut crossbeam::channel::Receiver<CEvent>,
      place_order: PlaceOrderFn,
      cancel_order: CancelOrderFn,
      config: StrategyConfig,
  ) -> i32 { ... }

  #[no_mangle]
  pub extern "C" fn stop() { ... }
  ```

- `run` выполняется в отдельном потоке (через `spawn_blocking`) и должен сам крутить цикл обработки событий до тех пор, пока не будет установлен флаг остановки (обычно через `AtomicBool`, который меняется в `stop()`).

---

## Доступные типы (из `mod types`)

### Рыночные события

```rust
#[repr(C)]
#[derive(Clone, Copy)]
pub struct CEvent {
    pub event_type: u8,      // 0 = book_ticker, 1 = trade
    pub data: CEventData,    // union ниже
    pub received_at_ns: u64, // время получения в ядре, нс
}

#[repr(C)]
#[derive(Clone, Copy)]
pub union CEventData {
    pub book_ticker: CBookTicker,
    pub trade: CTrade,
}
```

#### BookTicker (лучший бид/аск)

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct CBookTicker {
    pub symbol: [u8; 16],
    pub symbol_len: u8,
    pub bid_price: f64,
    pub ask_price: f64,
    pub bid_qty: f64,
    pub ask_qty: f64,
    pub time: i64, // биржевой timestamp
}

impl CBookTicker {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }
}
```

#### Trade (лента сделок)

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct CTrade {
    pub symbol: [u8; 16],
    pub symbol_len: u8,
    pub price: f64,
    pub qty: f64,   // в этой системе: qty < 0.0 => агрессивный SELL, qty > 0.0 => агрессивный BUY
    pub time: i64,  // биржевой timestamp
}

impl CTrade {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }
}
```

### Конфиг стратегии

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct StrategyConfig {
    pub symbol: [u8; 16],           // например, "SOLUSDT"
    pub symbol_len: u8,
    pub params_json: *const c_char, // JSON-строка с параметрами стратегии
}

impl StrategyConfig {
    pub fn symbol_str(&self) -> &str {
        unsafe { std::str::from_utf8_unchecked(&self.symbol[..self.symbol_len as usize]) }
    }

    /// Парсинг JSON-параметров в произвольную структуру (serde)
    pub fn parse_params<T: serde::de::DeserializeOwned>(&self) -> Result<T, serde_json::Error> {
        if self.params_json.is_null() {
            return serde_json::from_str("{}");
        }
        unsafe {
            let c_str = std::ffi::CStr::from_ptr(self.params_json);
            let json_str = c_str.to_str().unwrap_or("{}");
            serde_json::from_str(json_str)
        }
    }
}
```

Обычно стратегия описывает свои параметры так:

```rust
use serde::Deserialize;

#[derive(Debug, Clone, Deserialize)]
struct StrategyParams {
    #[serde(default = "default_order_size")]
    order_size_usd: f64,
    #[serde(default)]
    api_key: String,
    #[serde(default)]
    secret_key: String,
    // ... другие параметры ...
}

fn default_order_size() -> f64 { 100.0 }
```

И в `run`:

```rust
let params: StrategyParams = config
    .parse_params()
    .unwrap_or_else(|_| StrategyParams::default());
```

### Работа с ордерами

```rust
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct OrderResult {
    pub success: bool,
    pub order_id: i64,
    pub error_code: i32,
}

pub type OrderCallback = unsafe extern "C" fn(result: OrderResult);
```

#### Отправка ордеров

```rust
// order_type: 0 = LIMIT, 1 = MARKET
pub type PlaceOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    price: f64,         // для MARKET игнорируется
    quantity: f64,
    side: *const c_char, // "BUY" / "SELL"
    order_type: u8,       // 0 = LIMIT, 1 = MARKET
    callback: OrderCallback,
);
```

- Функция асинхронная: она возвращается сразу, фактический ответ от биржи приходит позже через `callback`.
- Стратегия должна передавать C‑строки (`CString`) и обрабатывать результат в коллбэке.

#### Отмена ордера

```rust
pub type CancelOrderFn = unsafe extern "C" fn(
    api_key: *const c_char,
    secret_key: *const c_char,
    symbol: *const c_char,
    order_id: i64,
    callback: OrderCallback,
);
```

---

## Как обычно выглядит `run`

Минимальный скелет стратегии:

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::time::Duration;
use std::ffi::CString;

use crossbeam::channel::Receiver;
use serde::Deserialize;

static SHOULD_STOP: AtomicBool = AtomicBool::new(false);

#[derive(Debug, Clone, Deserialize)]
struct StrategyParams {
    #[serde(default = "default_order_size")]
    order_size_usd: f64,
    #[serde(default)]
    api_key: String,
    #[serde(default)]
    secret_key: String,
}

fn default_order_size() -> f64 { 100.0 }

unsafe extern "C" fn on_order_placed(result: OrderResult) {
    if result.success {
        println!("Order placed, id={}", result.order_id);
    } else {
        println!("Order failed, code={}", result.error_code);
    }
}

#[no_mangle]
pub extern "C" fn run(
    rx_ptr: *mut Receiver<CEvent>,
    place_order: PlaceOrderFn,
    _cancel_order: CancelOrderFn,
    config: StrategyConfig,
) -> i32 {
    SHOULD_STOP.store(false, Ordering::Relaxed);

    let rx = unsafe { &*rx_ptr };
    let symbol = config.symbol_str().to_string();

    // Параметры из JSON
    let params: StrategyParams = config
        .parse_params()
        .unwrap_or_else(|_| StrategyParams::default());

    println!("Strategy started on {}", symbol);
    println!("Params: {:?}", params);

    while !SHOULD_STOP.load(Ordering::Relaxed) {
        match rx.recv_timeout(Duration::from_millis(10)) {
            Ok(event) => {
                match event.event_type {
                    0 => {
                        // BookTicker
                        let bt = unsafe { event.data.book_ticker };
                        if !bt.symbol_str().eq_ignore_ascii_case(&symbol) {
                            continue;
                        }
                        // здесь логика по bid/ask
                    }
                    1 => {
                        // Trade
                        let tr = unsafe { event.data.trade };
                        if !tr.symbol_str().eq_ignore_ascii_case(&symbol) {
                            continue;
                        }
                        // здесь логика по трейдам (qty < 0 = sell)
                    }
                    _ => {}
                }
            }
            Err(_) => {
                // timeout — просто продолжаем
            }
        }

        // При необходимости — выставление ордера:
        // let api_key = CString::new(params.api_key.as_str()).unwrap();
        // let secret_key = CString::new(params.secret_key.as_str()).unwrap();
        // let symbol_c = CString::new(symbol.as_str()).unwrap();
        // let side = CString::new("BUY").unwrap();
        // let order_type: u8 = 0; // LIMIT или 1 для MARKET
        // let price = ...;
        // let qty = ...;
        // unsafe {
        //     place_order(
        //         api_key.as_ptr(),
        //         secret_key.as_ptr(),
        //         symbol_c.as_ptr(),
        //         price,
        //         qty,
        //         side.as_ptr(),
        //         order_type,
        //         on_order_placed,
        //     );
        // }
    }

    println!("Strategy stopped");
    0
}

#[no_mangle]
pub extern "C" fn stop() {
    SHOULD_STOP.store(true, Ordering::Relaxed);
}
```

---

## Правила / ограничения для стратегий

- Стратегия **однопоточная**: `run` крутится в одном потоке, но:
  - коллбеки `OrderCallback` вызываются из других потоков → общий стейт нужно защищать (`Atomic*`, `Mutex` и т.п.).
- Не блокировать долго внутри цикла `run` (использовать `recv_timeout` с коротким таймаутом).
- Для строк в FFI:
  - в стратегии всегда создавать `CString`,
  - передавать `as_ptr()` в `place_order` / `cancel_order`.
- Для union `event.data` всегда использовать правильную ветку по `event_type` и `unsafe`.

---

Эту заготовку можно давать другим моделям как описание среды: какие типы доступны, как выглядит `run/stop`, как приходят данные (bookticker/trades) и как отправлять лимит/маркет ордера.